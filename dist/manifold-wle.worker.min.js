(()=>{function f(t,o,e,n=null,l=null,i=null){if("primitive"in e)switch(e.primitive){case"cube":case"cylinder":case"sphere":case"tetrahedron":l&&l(t,o,e);break;default:{let a=e.primitive;throw new Error(`Unknown primitive: ${a}`)}}else if("operation"in e)switch(e.operation){case"add":case"union":case"subtract":case"difference":case"intersect":case"intersection":{if("manifolds"in e)for(let a=e.manifolds.length-1;a>=0;a--)f(e.manifolds,a,e.manifolds[a],n,l,i);else f(e,"right",e.right,n,l,i),f(e,"left",e.left,n,l,i);i&&i(t,o,e);break}case"translate":case"rotate":case"scale":case"transform":case"refine":case"asOriginal":f(e,"manifold",e.manifold,n,l,i);case"extrude":case"revolve":i&&i(t,o,e);break;default:{let a=e.operation;throw a==="compose"||a==="decompose"?new Error(`${a} operation is not implemented yet`):new Error(`Unknown operation: ${a}`)}}else n&&n(t,o,e)}function k(t,o=null,e=null,n=null,l=null){let i={root:t};if("primitive"in t)e&&e(i,"root",t);else switch(t.operation){case"isEmpty":case"numVert":case"numTri":case"numEdge":case"boundingBox":case"precision":case"genus":case"getProperties":case"getCurvature":case"originalID":f(t,"manifold",t.manifold,o,e,n),l&&l(i,"root",t);break;default:f(i,"root",t,o,e,n)}}function c(t,o){t(`[Worker ${self.name}] ${o}`)}var u=null,b={add:"union",union:"union",subtract:"difference",difference:"difference",intersect:"intersection",intersection:"intersection"};function h(t){let o=u,e=new Array,n,l=[];if(k(t,(i,a,[r,s])=>{let p=new o.Manifold(s);l.push([p.originalID(),r]),e.push(p)},(i,a,r)=>{switch(r.primitive){case"cube":e.push(o.cube(r.size,r.center));break;case"cylinder":e.push(o.cylinder(r.height,r.radiusLow,r.radiusHigh,r.circularSegments,r.center));break;case"sphere":e.push(o.sphere(r.radius,r.circularSegments));break;case"tetrahedron":e.push(o.tetrahedron());break;default:throw new Error(`Unknown primitive: ${r.primitive}`)}},(i,a,r)=>{switch(r.operation){case"add":case"union":case"subtract":case"difference":case"intersect":case"intersection":{let s=o[b[r.operation]];if("manifolds"in r){let p=r.manifolds.length,g=new Array;for(let m=0;m<p;m++){let y=e.pop();if(y===void 0)throw new Error(`Expected ${p} manifolds in the stack, got ${m}`);g.push(y)}e.push(s(g))}else{if(e.length<2)throw new Error(`Expected at least 2 manifolds in the stack, got ${e.length}`);e.push(s(e.pop(),e.pop()))}break}case"translate":case"rotate":case"scale":case"transform":case"refine":case"asOriginal":{if(e.length<1)throw new Error(`Expected at least 1 manifold on the stack, got ${e.length}`);let s=e.pop(),p;switch(r.operation){case"translate":p=s.translate(r.offset);break;case"rotate":p=s.rotate(r.degrees);break;case"scale":p=s.scale(r.factor);break;case"transform":p=s.transform(r.matrix);break;case"refine":p=s.refine(r.splits);break;case"asOriginal":p=s.asOriginal()}e.push(p);break}case"extrude":e.push(o.extrude(r.crossSection,r.height,r.nDivisions,r.twistDegrees,r.scaleTop));break;case"revolve":e.push(o.revolve(r.crossSection,r.circularSegments));break;default:{let s=r.operation;throw s==="compose"||s==="decompose"?new Error(`${s} operation is not implemented yet`):new Error(`Unknown operation: ${s}`)}}},(i,a,r)=>{if(e.length!==1)throw new Error(`Expected 1 manifold on the stack, got ${e.length}`);if(n!==void 0)throw new Error("Expected no current result, but result was already set");let s=e.pop();switch(r.operation){case"isEmpty":n=s.isEmpty();break;case"numVert":n=s.numVert();break;case"numTri":n=s.numTri();break;case"numEdge":n=s.numEdge();break;case"boundingBox":n=s.boundingBox();break;case"precision":n=s.precision();break;case"genus":n=s.genus();break;case"getProperties":n=s.getProperties();break;case"getCurvature":n=s.getCurvature();break;case"originalID":n=s.originalID();break;default:throw new Error(`Unknown top operation: ${r.operation}`)}}),n===void 0){if(e.length===1)return[e[0].getMesh(),e[0].getMeshRelation(),l];throw new Error(`Unexpected number of manifolds in stack (${e.length}) after evaluation`)}else{if(e.length===0)return n;throw new Error("Manifolds stack expected to be empty, but isn't")}}globalThis.onmessage=async function(t){switch(t.data.type){case"initialize":if(!u)try{c(console.debug,`Initializing worker with libary path "${t.data.libraryPath}"`),importScripts(t.data.libraryPath),c(console.debug,"Imported library successfuly"),u=await Module(),c(console.debug,"Done waiting for module"),u.setup(),c(console.debug,"Module setup finished")}catch(o){u=null,c(console.debug,"Initialization failed"),c(console.error,o),postMessage({type:"crash",error:o});return}c(console.debug,"Ready"),postMessage({type:"ready"});return;case"terminate":u=null,c(console.debug,"Terminated"),postMessage({type:"terminated"});return;case"operation":{if(!u){postMessage({type:"result",success:!1,jobID:t.data.jobID,error:"Worker is not ready yet"});return}c(console.debug,`Job ${t.data.jobID} started`);try{postMessage({type:"result",success:!0,jobID:t.data.jobID,result:h(t.data.operation)})}catch(o){c(console.debug,`Job ${t.data.jobID} failed`),c(console.error,o),postMessage({type:"result",success:!1,jobID:t.data.jobID,error:o});return}c(console.debug,`Job ${t.data.jobID} finished`);return}default:{let e=`Unknown worker request type: ${t.data.type}`;c(console.error,e),postMessage({type:"crash",error:e})}}};c(console.debug,"Created");postMessage({type:"created"});})();
//# sourceMappingURL=manifold-wle.worker.min.js.map
