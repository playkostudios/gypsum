{
  "version": 3,
  "sources": ["../src/common/iterate-operation-tree.ts", "../src/worker.ts"],
  "sourcesContent": ["import type { CSGFinalOperation } from './CSGFinalOperation';\nimport { CSGGeometricOperation } from './CSGGeometricOperation';\nimport type { CSGOperation } from './CSGOperation';\nimport type { CSGPrimitive } from './CSGPrimitive';\nimport type { CSGTree } from './CSGTree';\n\nexport type OpTreeCtx<MeshType> = { [key: string | number]: (CSGTree<MeshType> | MeshType) };\n\nfunction iterateOpTreeNode<MeshType>(context: OpTreeCtx<MeshType>, key: string | number, node: CSGTree<MeshType> | MeshType, handleMesh: ((context: OpTreeCtx<MeshType>, key: string | number, mesh: MeshType) => void) | null = null, handlePrimitive: ((context: OpTreeCtx<MeshType>, key: string | number, operation: CSGPrimitive) => void) | null = null, handleOperation: ((context: OpTreeCtx<MeshType>, key: string | number, operation: CSGGeometricOperation<MeshType>) => void) | null = null): void {\n    if ('primitive' in node) {\n        // primitive\n        switch (node.primitive) {\n            case 'cube':\n            case 'cylinder':\n            case 'sphere':\n            case 'tetrahedron':\n                if (handlePrimitive) {\n                    handlePrimitive(context, key, node);\n                }\n                break;\n            default: {\n                // XXX we're kinda fighting the type system here, but oh well\n                const prim = (node as {primitive: string}).primitive;\n                throw new Error(`Unknown primitive: ${prim}`);\n            }\n        }\n    } else if ('operation' in node) {\n        // operation\n        switch (node.operation) {\n            case 'add':\n            case 'union':\n            case 'subtract':\n            case 'difference':\n            case 'intersect':\n            case 'intersection': {\n                // XXX children are iterated from right to left so that they can\n                // be pushed to a stack and then popped at the right order\n                if ('manifolds' in node) {\n                    for (let i = node.manifolds.length - 1; i >= 0; i--) {\n                        iterateOpTreeNode(node.manifolds as unknown as OpTreeCtx<MeshType>, i, node.manifolds[i], handleMesh, handlePrimitive, handleOperation);\n                    }\n                } else {\n                    iterateOpTreeNode(node as unknown as OpTreeCtx<MeshType>, 'right', node.right, handleMesh, handlePrimitive, handleOperation);\n                    iterateOpTreeNode(node as unknown as OpTreeCtx<MeshType>, 'left', node.left, handleMesh, handlePrimitive, handleOperation);\n                }\n\n                if (handleOperation) {\n                    handleOperation(context, key, node);\n                }\n                break;\n            }\n            case 'translate':\n            case 'rotate':\n            case 'scale':\n            case 'transform':\n            case 'refine':\n            case 'asOriginal':\n                iterateOpTreeNode(node as unknown as OpTreeCtx<MeshType>, 'manifold', node.manifold, handleMesh, handlePrimitive, handleOperation);\n                // XXX intentional fallthrough\n            case 'extrude':\n            case 'revolve':\n                if (handleOperation) {\n                    handleOperation(context, key, node);\n                }\n                break;\n            default: {\n                // XXX fighting the type system again...\n                const op = (node as {operation: string}).operation;\n                if (op === 'compose' || op === 'decompose') {\n                    throw new Error(`${op} operation is not implemented yet`);\n                } else {\n                    throw new Error(`Unknown operation: ${op}`);\n                }\n            }\n        }\n    } else {\n        // assume this is a mesh object\n        if (handleMesh) {\n            handleMesh(context, key, node);\n        }\n    }\n}\n\nexport function iterateOpTree<MeshType>(tree: CSGOperation<MeshType>, handleMesh: ((context: OpTreeCtx<MeshType>, key: string | number, mesh: MeshType) => void) | null = null, handlePrimitive: ((context: OpTreeCtx<MeshType>, key: string | number, operation: CSGPrimitive) => void) | null = null, handleOperation: ((context: OpTreeCtx<MeshType>, key: string | number, operation: CSGGeometricOperation<MeshType>) => void) | null = null, handleTopOperation: ((context: OpTreeCtx<MeshType>, key: string | number, topOperation: CSGFinalOperation<MeshType>) => void) | null = null): void {\n    const context = <OpTreeCtx<MeshType>>{\n        root: tree\n    };\n\n    if ('primitive' in tree) {\n        if (handlePrimitive) {\n            handlePrimitive(context, 'root', tree);\n        }\n    } else {\n        switch (tree.operation) {\n            case 'isEmpty':\n            case 'numVert':\n            case 'numTri':\n            case 'numEdge':\n            case 'boundingBox':\n            case 'precision':\n            case 'genus':\n            case 'getProperties':\n            case 'getCurvature':\n            case 'originalID':\n                iterateOpTreeNode(tree as unknown as OpTreeCtx<MeshType>, 'manifold', tree.manifold, handleMesh, handlePrimitive, handleOperation);\n\n                if (handleTopOperation) {\n                    handleTopOperation(context, 'root', tree);\n                }\n                break;\n            default:\n                iterateOpTreeNode(context, 'root', tree, handleMesh, handlePrimitive, handleOperation);\n        }\n    }\n}", "// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path=\"../types/globals.d.ts\" />\n\nimport { iterateOpTree } from './common/iterate-operation-tree';\nimport type { WorkerRequest, WorkerOperation } from './common/WorkerRequest';\nimport type { WorkerResponse, WorkerResult, WorkerIDMap } from './common/WorkerResponse';\n\nfunction logWorker(callback: (message: string) => void, message: unknown) {\n    callback(`[Worker ${self.name}] ${message}`);\n}\n\nlet manifoldModule: ManifoldStatic | null = null;\n\nconst boolOpMap: Record<string, 'union' | 'difference' | 'intersection'> = {\n    add: 'union',\n    union: 'union',\n    subtract: 'difference',\n    difference: 'difference',\n    intersect: 'intersection',\n    intersection: 'intersection',\n};\n\nfunction evaluateOpTree(tree: WorkerOperation): WorkerResult {\n    const manifold = manifoldModule as ManifoldStatic;\n    const stack = new Array<Manifold>();\n    let result: WorkerResult | undefined = undefined;\n    const idMap: WorkerIDMap = [];\n\n    iterateOpTree(tree, (_context, _key, [meshID, mesh]) => {\n        // mesh\n        // logWorker(console.debug, 'Adding mesh as manifold to stack');\n\n        const meshManif = new manifold.Manifold(mesh);\n        idMap.push([meshManif.originalID(), meshID]);\n        stack.push(meshManif);\n    }, (_context, _key, node) => {\n        // primitive\n        // logWorker(console.debug, `Adding primitive (${node.primitive}) to stack`);\n\n        switch (node.primitive) {\n            case 'cube':\n                stack.push(manifold.cube(\n                    node.size, node.center\n                ));\n                break;\n            case 'cylinder':\n                stack.push(manifold.cylinder(\n                    node.height, node.radiusLow, node.radiusHigh,\n                    node.circularSegments, node.center\n                ));\n                break;\n            case 'sphere':\n                stack.push(manifold.sphere(\n                    node.radius, node.circularSegments\n                ));\n                break;\n            case 'tetrahedron':\n                stack.push(manifold.tetrahedron());\n                break;\n            default:\n                throw new Error(`Unknown primitive: ${(node as {primitive: string}).primitive}`);\n        }\n    }, (_context, _key, node) => {\n        // operation\n        // logWorker(console.debug, `Starting operation (${node.operation})...`);\n\n        switch (node.operation) {\n            case 'add':\n            case 'union':\n            case 'subtract':\n            case 'difference':\n            case 'intersect':\n            case 'intersection': {\n                const opFunc = manifold[boolOpMap[node.operation]];\n\n                if ('manifolds' in node) {\n                    const wantedCount = node.manifolds.length;\n                    const manifolds = new Array<Manifold>();\n\n                    // logWorker(console.debug, `Popping ${wantedCount} manifolds, pushing 1`);\n\n                    for (let i = 0; i < wantedCount; i++) {\n                        const next = stack.pop();\n                        if (next === undefined) {\n                            throw new Error(`Expected ${wantedCount} manifolds in the stack, got ${i}`);\n                        }\n\n                        manifolds.push(next);\n                    }\n\n                    stack.push(opFunc(manifolds));\n                } else {\n                    // logWorker(console.debug, 'Popping 2 manifolds, pushing 1');\n\n                    if (stack.length < 2) {\n                        throw new Error(`Expected at least 2 manifolds in the stack, got ${stack.length}`);\n                    }\n\n                    stack.push(opFunc(\n                        stack.pop() as Manifold,\n                        stack.pop() as Manifold\n                    ));\n                }\n\n                break;\n            }\n            case 'translate':\n            case 'rotate':\n            case 'scale':\n            case 'transform':\n            case 'refine':\n            case 'asOriginal': {\n                // logWorker(console.debug, 'Popping 1 manifold, pushing 1');\n\n                if (stack.length < 1) {\n                    throw new Error(`Expected at least 1 manifold on the stack, got ${stack.length}`);\n                }\n\n                const top = stack.pop() as Manifold;\n                let res: Manifold;\n\n                switch(node.operation) {\n                    case 'translate':\n                        res = top.translate(node.offset);\n                        break;\n                    case 'rotate':\n                        res = top.rotate(node.degrees);\n                        break;\n                    case 'scale':\n                        res = top.scale(node.factor);\n                        break;\n                    case 'transform':\n                        res = top.transform(node.matrix);\n                        break;\n                    case 'refine':\n                        res = top.refine(node.splits);\n                        break;\n                    case 'asOriginal':\n                        res = top.asOriginal();\n                }\n\n                stack.push(res);\n                break;\n            }\n            case 'extrude':\n                // logWorker(console.debug, 'Pushing 1 manifold');\n\n                stack.push(manifold.extrude(\n                    node.crossSection, node.height, node.nDivisions,\n                    node.twistDegrees, node.scaleTop\n                ));\n                break;\n            case 'revolve':\n                // logWorker(console.debug, 'Pushing 1 manifold');\n\n                stack.push(manifold.revolve(\n                    node.crossSection, node.circularSegments\n                ));\n                break;\n            default: {\n                // XXX fighting the type system again...\n                const op = (node as {operation: string}).operation;\n                if (op === 'compose' || op === 'decompose') {\n                    throw new Error(`${op} operation is not implemented yet`);\n                } else {\n                    throw new Error(`Unknown operation: ${op}`);\n                }\n            }\n        }\n\n        // logWorker(console.debug, 'Operation finished');\n    }, (_context, _key, root) => {\n        // logWorker(console.debug, 'Top operation. Popping 1 manifold');\n        // top operation\n        if (stack.length !== 1) {\n            throw new Error(`Expected 1 manifold on the stack, got ${stack.length}`);\n        }\n        if (result !== undefined) {\n            throw new Error('Expected no current result, but result was already set');\n        }\n\n        const top = stack.pop() as Manifold;\n        switch (root.operation) {\n            case 'isEmpty':\n                result = top.isEmpty();\n                break;\n            case 'numVert':\n                result = top.numVert();\n                break;\n            case 'numTri':\n                result = top.numTri();\n                break;\n            case 'numEdge':\n                result = top.numEdge();\n                break;\n            case 'boundingBox':\n                result = top.boundingBox();\n                break;\n            case 'precision':\n                result = top.precision();\n                break;\n            case 'genus':\n                result = top.genus();\n                break;\n            case 'getProperties':\n                result = top.getProperties();\n                break;\n            case 'getCurvature':\n                result = top.getCurvature();\n                break;\n            case 'originalID':\n                result = top.originalID();\n                break;\n            default:\n                throw new Error(`Unknown top operation: ${(root as {operation: string}).operation}`);\n        }\n    });\n\n    if (result === undefined) {\n        if (stack.length === 1) {\n            return [ stack[0].getMesh(), stack[0].getMeshRelation(), idMap ];\n        } else {\n            throw new Error(`Unexpected number of manifolds in stack (${stack.length}) after evaluation`);\n        }\n    } else {\n        if (stack.length === 0) {\n            return result;\n        } else {\n            throw new Error(\"Manifolds stack expected to be empty, but isn't\");\n        }\n    }\n}\n\nglobalThis.onmessage = async function(message: MessageEvent<WorkerRequest>) {\n    switch(message.data.type) {\n        case 'initialize':\n            if (!manifoldModule) {\n                try {\n                    logWorker(console.debug, `Initializing worker with libary path \"${message.data.libraryPath}\"`);\n                    importScripts(message.data.libraryPath);\n                    logWorker(console.debug, `Imported library successfuly`);\n                    manifoldModule = await Module();\n                    logWorker(console.debug, `Done waiting for module`);\n                    manifoldModule.setup();\n                    logWorker(console.debug, `Module setup finished`);\n                } catch(error) {\n                    // TODO clean up module properly\n                    manifoldModule = null;\n                    logWorker(console.debug, 'Initialization failed');\n                    logWorker(console.error, error);\n                    postMessage(<WorkerResponse>{ type: 'crash', error });\n                    return;\n                }\n            }\n\n            logWorker(console.debug, 'Ready');\n            postMessage(<WorkerResponse>{ type: 'ready' });\n            return;\n        case 'terminate':\n            // TODO clean up module properly\n            manifoldModule = null;\n            logWorker(console.debug, 'Terminated');\n            postMessage(<WorkerResponse>{ type: 'terminated' });\n            return;\n        case 'operation': {\n            if (!manifoldModule) {\n                postMessage(<WorkerResponse>{\n                    type: 'result',\n                    success: false,\n                    jobID: message.data.jobID,\n                    error: 'Worker is not ready yet'\n                });\n                return;\n            }\n\n            logWorker(console.debug, `Job ${message.data.jobID} started`);\n\n            try {\n                postMessage(<WorkerResponse>{\n                    type: 'result',\n                    success: true,\n                    jobID: message.data.jobID,\n                    result: evaluateOpTree(message.data.operation),\n                });\n            } catch(error) {\n                logWorker(console.debug, `Job ${message.data.jobID} failed`);\n                logWorker(console.error, error);\n                postMessage(<WorkerResponse>{\n                    type: 'result',\n                    success: false,\n                    jobID: message.data.jobID,\n                    error,\n                });\n                return;\n            }\n\n            logWorker(console.debug, `Job ${message.data.jobID} finished`);\n            return;\n        }\n        default: {\n            // XXX fighting the type system again...\n            const type = (message.data as {type: string}).type;\n            const error = `Unknown worker request type: ${type}`;\n            logWorker(console.error, error);\n            postMessage(<WorkerResponse>{ type: 'crash', error });\n        }\n    }\n}\n\nlogWorker(console.debug, 'Created');\npostMessage(<WorkerResponse>{ type: 'created' });"],
  "mappings": "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",
  "names": ["iterateOpTreeNode", "context", "key", "node", "handleMesh", "handlePrimitive", "handleOperation", "prim", "i", "op", "iterateOpTree", "tree", "handleTopOperation", "logWorker", "callback", "message", "manifoldModule", "boolOpMap", "evaluateOpTree", "tree", "manifold", "stack", "result", "idMap", "iterateOpTree", "_context", "_key", "meshID", "mesh", "meshManif", "node", "opFunc", "wantedCount", "manifolds", "i", "next", "top", "res", "op", "root", "error"]
}
