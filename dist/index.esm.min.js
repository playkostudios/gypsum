import{vec2 as St}from"gl-matrix";var Ot=Math.PI*2;function ct(n,e,t=!1){if(e<3)throw new Error("There must be at least 3 sides in a regular polyline");let r=new Array(e),s=e-1;for(let o=0;o<e;o++){let a=t?o:s-o,u=Ot*a/e,c=Math.cos(u)*n,l=Math.sin(u)*n;r[o]=St.fromValues(l,c)}return r}function Yt(n,e=!1,t=12){return ct(n,t,e)}import{vec2 as oe}from"gl-matrix";function Kt(n,e=!1){let t=n/2;return e?[oe.fromValues(t,t),oe.fromValues(t,-t),oe.fromValues(-t,-t),oe.fromValues(-t,t)]:[oe.fromValues(t,t),oe.fromValues(-t,t),oe.fromValues(-t,-t),oe.fromValues(t,-t)]}import{vec2 as ae}from"gl-matrix";function Zt(n,e,t=!1){let r=n/2,s=e/2;return t?[ae.fromValues(r,s),ae.fromValues(r,-s),ae.fromValues(-r,-s),ae.fromValues(-r,s)]:[ae.fromValues(r,s),ae.fromValues(-r,s),ae.fromValues(-r,-s),ae.fromValues(r,-s)]}import{vec2 as ut}from"gl-matrix";var mt=Math.PI*2;function rr(n,e,t,r=!1){if(t<3)throw new Error("There must be at least 3 sides in a star polyline");let s=new Array(t*2),o=t-1,a=mt/t/2,u=0;for(let c=0;c<t;c++){let l=r?c:o-c,i=mt*l/t,f=Math.cos(i)*n,h=Math.sin(i)*n,b=ut.fromValues(h,f),m=i+a,y=Math.cos(m)*e,p=Math.sin(m)*e,x=ut.fromValues(p,y);r?(s[u++]=b,s[u++]=x):(s[u++]=x,s[u++]=b)}return s}import{quat as ht,vec3 as W}from"gl-matrix";var Bt=Math.PI/2,Dt=Math.PI*2,ze=ht.create(),Nt=W.create(),jt=W.create(),ft=W.create();function or(n,e,t,r){let s=n.length;if(e.length<s)throw new Error("There must be at least one tangent per point");if(s<2)throw new Error("There must be at least 1 segment (2 points) in the curve");let o=new Array(s),a=e[0],u=W.cross(W.create(),a,t);o[0]=[t,u,a];for(let i=0;i<s-1;i++){let f=W.sub(Nt,n[i+1],n[i]),h=W.dot(f,f),b=o[i][0],m=o[i][2],y=-2/h,p=W.scaleAndAdd(jt,b,f,W.dot(f,b)*y),x=W.scaleAndAdd(ft,m,f,W.dot(f,m)*y),g=e[i+1],V=W.sub(ft,g,x),E=W.dot(V,V),P=W.scaleAndAdd(W.create(),p,V,W.dot(V,p)*-2/E),S=W.cross(W.create(),g,P);o[i+1]=[P,S,g]}let c=r?.endNormal,l=r?.twists??0;if(c||l>0){let i=0;if(c){let f=e[s-1],h=W.cross(W.create(),f,c),b=o[s-1][0],m=W.dot(h,b),y=W.dot(c,b);m!==0&&y!==0&&(i=Math.atan2(y,m)-Bt)}if(i+=Dt*l,i!==0){let f=0,h=n[0];for(let m=1;m<s;m++){let y=n[m];f+=W.distance(h,y),h=y}let b=0;h=n[0];for(let m=1;m<s;m++){let[y,p,x]=o[m],g=n[m];b+=W.distance(h,g),h=g;let V=i*b/f;ht.setAxisAngle(ze,e[m],V),W.transformQuat(y,y,ze),W.transformQuat(p,p,ze)}}}return o}import{vec3 as Fe}from"gl-matrix";var Ie=class{constructor(){this.buckets=new Map}murmur_32_scramble(e){return e*=3432918353,e=e<<15|e>>17,e*=461845907,e&4294967295}murmur3_32(e,t){let r=t,s=new Uint32Array(e.buffer);for(let o of s)r^=this.murmur_32_scramble(o),r=r<<13&4294967295|r>>19,r=r*5+3864292196&4294967295;return r^=s.byteLength,r^=r>>16,r=r*2246822507&4294967295,r^=r>>13,r=r*3266489909&4294967295,r^=r>>16,r}getHash(e){return this.murmur3_32(e,3935228948)}isUnique(e){let t=this.getHash(e),r=this.buckets.get(t);if(r){for(let s of r)if(e[0]===s[0]&&e[1]===s[1]&&e[2]===s[2])return!1;r.push(e)}else this.buckets.set(t,[e]);return!0}clear(){this.buckets.clear()}};var bt=4294967296,we=Fe.create(),pt=Fe.create(),I=class{constructor(e=[],t,r){this.submeshes=e;this.premadeManifoldMesh=t;this.submeshMap=r}get manifoldMesh(){if(!this.premadeManifoldMesh){let e=new Array(this.submeshes.length),t=0;for(let[r,s]of this.submeshes)e[t++]=r;[this.submeshMap,this.premadeManifoldMesh]=I.manifoldFromWLE(e)}return this.premadeManifoldMesh}get submeshCount(){return this.submeshes.length}getSubmesh(e){let t=this.submeshes[e];if(!t)throw new Error(`No submesh exists at index ${e}`);return t}getSubmeshes(){let e=new Array(this.submeshCount);for(let t=0;t<this.submeshCount;t++){let r=this.submeshes[t];e[t]=[r[0],r[1]]}return e}getTriBarySubmesh(e){if(!this.submeshMap)throw new Error("Missing submesh map");let t=e*2;return[this.getSubmesh(this.submeshMap[t]),this.submeshMap[t+1]]}static manifoldToWLE(e){let t=e.triVerts.length,r=t*3,s=new Uint32Array(r);for(let l=0;l<r;l++)s[l]=l;let o=new WL.Mesh({indexData:s,indexType:WL.MeshIndexType.UnsignedInt,vertexCount:r}),a=o.attribute(WL.MeshAttribute.Position),u=o.attribute(WL.MeshAttribute.Normal),c=0;for(let l=0;l<t;l++){let i=e.triVerts[l],f=i[0],h=i[1],b=i[2],m=e.vertPos[f],y=e.vertPos[h],p=e.vertPos[b];u&&(e.vertNormal?(u.set(c,e.vertNormal[f]),u.set(c+1,e.vertNormal[h]),u.set(c+2,e.vertNormal[b])):(Fe.sub(we,y,m),Fe.sub(pt,y,p),Fe.cross(we,pt,we),u.set(c,we),u.set(c+1,we),u.set(c+2,we))),a.set(c++,m),a.set(c++,y),a.set(c++,p)}return o}static manifoldFromWLE(e,t=!0){Array.isArray(e)||(e=[e]);let r=0;for(let i of e){let f=i.vertexCount,h=i.indexData,b=h===null?f:h.length;if(b%3!==0)throw new Error(`Mesh has an invalid vertex count (${b}). Must be a multiple of 3`);r+=b}let s=r/3,o={vertPos:new Array,triVerts:new Array(s)},a=new Ie,u=t?new Float32Array(s*2):null,c=0,l=0;for(let i=0;i<e.length;i++){let f=e[i],h=f.attribute(WL.MeshAttribute.Position),b=f.vertexCount,m=f.indexData,y=m===null?b:m.length,p=new Array;for(let g=0;g<b;g++){let V=h.get(g);if(a.isUnique(V))p.push(o.vertPos.length),o.vertPos.push(V);else{let[E,P,S]=V,L=0;for(;L<o.vertPos.length;L++){let[j,R,te]=o.vertPos[L];if(j===E&&R===P&&te===S)break}L===o.vertPos.length?(p.push(o.vertPos.length),o.vertPos.push(V)):p.push(L)}}let x=0;if(m===null)for(let g=0;g<y;)o.triVerts[c++]=[p[g++],p[g++],p[g++]],u&&(u[l++]=i,u[l++]=x++);else for(let g=0;g<y;)o.triVerts[c++]=[p[m[g++]],p[m[g++]],p[m[g++]]],u&&(u[l++]=i,u[l++]=x++)}if(c!==o.triVerts.length)throw new Error("Unexpected manifold triangle count");if(u){if(l!==u.length)throw new Error(`Unexpected iterator position for submeshMap; expected ${u.length}, got ${l}`);return[u,o]}else return o}static makeIndexBuffer(e){if(e<256)return[new Uint8Array(e),WL.MeshIndexType.UnsignedByte];if(e<65536)return[new Uint16Array(e),WL.MeshIndexType.UnsignedShort];if(e<bt)return[new Uint32Array(e),WL.MeshIndexType.UnsignedInt];throw new Error(`Maximum index buffer size exceeded (${bt})`)}};var dt=Symbol();function gt(n,e){return[[0,e],[0,0],[n,0],[n,e]]}function ve(n,e,t,r,s,o,a){let u=new WL.Mesh(a),c=u.attribute(WL.MeshAttribute.Position);if(!c)throw new Error("Could not get position MeshAttributeAccessor");let l=u.attribute(WL.MeshAttribute.Normal),i=u.attribute(WL.MeshAttribute.TextureCoordinate),f;return i&&(r?typeof r=="number"?f=gt(s*r,o*r):f=r:f=gt(s,o)),c.set(0,[...e[n[0]],...e[n[1]],...e[n[2]],...e[n[3]]]),l&&(l.set(0,t),l.set(1,t),l.set(2,t),l.set(3,t)),i&&i.set(0,[...f[0],...f[1],...f[2],...f[3]]),u}function Rt(n,e){let t=e.length;for(let r=0,s=0;r<t;r++){let o=e[r];n[s++]=[o[0],o[1],o[2]],n[s++]=[o[0],o[2],o[3]]}}var Ce=class extends I{constructor(t,r,s,o){var e=(...args)=>{super(...args)};if(arguments.length===1&&Array.isArray(t)&&t.length===7&&t[0]===dt){let D=t;e(D[4],D[5],D[6]),this.width=D[1],this.height=D[2],this.depth=D[3];return}else if(arguments.length!==3&&arguments.length!==4)throw new Error("Unexpected number of arguments. Expected 3 or 4 arguments");let a=t,u=r,c=s,l=o,i=WL.MeshIndexType.UnsignedByte,f=new Uint8Array(6);f[0]=0,f[1]=1,f[2]=2,f[3]=0,f[4]=2,f[5]=3;let h=l?.center??!0,b=h?-a/2:0,m=h?a/2:a,y=h?-u/2:0,p=h?u/2:u,x=h?-c/2:0,g=h?c/2:c,V=[[b,y,x],[m,y,x],[b,p,x],[m,p,x],[b,y,g],[m,y,g],[b,p,g],[m,p,g]],E=[[2,0,4,6],[7,5,1,3],[4,0,1,5],[2,6,7,3],[3,1,0,2],[6,4,5,7]],P=new Array(12);Rt(P,E);let S={triVerts:P,vertPos:V},L={vertexCount:4,indexData:f,indexType:i},j=ve(E[0],V,[-1,0,0],l?.leftUVs,c,u,L),R=ve(E[1],V,[1,0,0],l?.rightUVs,c,u,L),te=ve(E[2],V,[0,-1,0],l?.downUVs,a,c,L),B=ve(E[3],V,[0,1,0],l?.upUVs,a,c,L),ie=ve(E[4],V,[0,0,-1],l?.backUVs,a,u,L),v=ve(E[5],V,[0,0,1],l?.frontUVs,a,u,L),pe=new Float32Array([0,0,0,1,1,0,1,1,2,0,2,1,3,0,3,1,4,0,4,1,5,0,5,1]);e([[j,l?.leftMaterial??null],[R,l?.rightMaterial??null],[te,l?.downMaterial??null],[B,l?.upMaterial??null],[ie,l?.backMaterial??null],[v,l?.frontMaterial??null]],S,pe),this.width=a,this.height=u,this.depth=c}clone(t){return new Ce([dt,this.width,this.height,this.depth,[[this.submeshes[0][0],t?.leftMaterial??null],[this.submeshes[1][0],t?.rightMaterial??null],[this.submeshes[2][0],t?.downMaterial??null],[this.submeshes[3][0],t?.upMaterial??null],[this.submeshes[4][0],t?.backMaterial??null],[this.submeshes[5][0],t?.frontMaterial??null]],this.premadeManifoldMesh,this.submeshMap])}};var Mt=class extends Ce{constructor(e,t){super(e,e,e,t)}};import{mat3 as vt,mat4 as Vt,vec3 as U}from"gl-matrix";function be(n){let e=0,t=n.length,r=n[t-1];for(let s of n)e+=(s[0]-r[0])*(s[1]+r[1]),r=s;return e>=0}function Se(n){let e=Array.from({length:n.length},(t,r)=>r);return e.sort((t,r)=>{let s=n[t],o=n[r];return s[0]<o[0]?-1:s[0]>o[0]?1:s[1]<o[1]?-1:s[1]>o[1]?1:0}),e}function yt(n,e,t){let r=n.length,s=[e];for(let o=(n.indexOf(e)+1)%r;;o=(o+1)%r){let a=n[o];if(s.push(a),a===t)return s;if(a===e)throw new Error(`getPolygonInLoop aborted; infinite loop detected due to possibly invalid split diagonal (${e}, ${t})`)}}function Je(n,e,t,r,s){if(t.length>0){let[o,a]=t[0],u=yt(e,o,a),c=yt(e,a,o),l=new Array,i=new Array,f=t.length;for(let h=1;h<f;h++){let[b,m]=t[h];if(u.indexOf(b)>=0&&u.indexOf(m)>=0)l.push([b,m]);else if(c.indexOf(b)>=0&&c.indexOf(m)>=0)i.push([b,m]);else throw new Error(`Invalid split diagonal (${b}, ${m})`)}Je(n,u,l,r,s),Je(n,c,i,r,s)}else{let o=e.length,a=new Array(o);if(s)for(let u=0;u<o;u++)a[u]=n[e[o-1-u]];else for(let u=0;u<o;u++)a[u]=n[e[u]];r.push(a)}}function Ke(n,e,t,r=!1){return t||(t=[]),Je(n,Array.from({length:n.length},(s,o)=>o),e,t,r),t}var qe=Math.PI*2;function xt(n,e){return n[0]<e[0]||n[0]===e[0]&&n[1]<e[1]}function At(n,e,t){let r=-Math.atan2(n[1]-e[1],n[0]-e[0]);return((-Math.atan2(t[1]-e[1],t[0]-e[0])-r)%qe+qe)%qe}function He(n,e,t,r){let s=-1,o=-1/0;for(let a of e){let u=(a+1)%t,c=n[a],l=n[u],i,f;if(c[0]>l[0]?(i=l,f=c):(f=l,i=c),r[0]>=i[0]&&r[0]<=f[0]){let h=(f[1]-i[1])/(f[0]-i[0]),b=i[1]-h*i[0],m=h*r[0]+b;m<=r[1]&&m>=o&&(o=m,s=a)}}if(s===-1)throw new Error(`No edge to the left of vertex. Status: ${Array.from(e)}`);return s}function Ze(n,e,t){t===void 0&&(t=be(n)),t&&(n=n.slice().reverse());let r=n.length,s=new Map,o=new Set,a=new Map,u=new Array;for(let c of Se(n)){let l=(c-1%r+r)%r,i=(c+1)%r,f=n[l],h=n[c],b=n[i],m=xt(h,f),y=xt(h,b);if(m&&y){if(At(f,h,b)<Math.PI)a.set(c,0);else{a.set(c,3);let p=He(n,o,r,h);u.push([c,s.get(p)]),s.set(p,c)}o.add(c),s.set(c,c);continue}else if(!m&&!y){let p=s.get(l);if(p!==void 0&&a.get(p)===4&&u.push([c,p]),o.delete(l),At(f,h,b)<Math.PI)a.set(c,1);else{a.set(c,4);let x=He(n,o,r,h),g=s.get(x);g!==void 0&&a.get(g)===4&&u.push([c,g]),s.set(x,c)}continue}if(a.set(c,2),b[0]>h[0]){let p=s.get(l);p!==void 0&&a.get(p)===4&&u.push([c,p]),o.delete(l),o.add(c),s.set(c,c)}else{let p=He(n,o,r,h),x=s.get(p);x!==void 0&&a.get(x)===4&&u.push([c,x]),s.set(p,c)}}return Ke(n,u,e,t)}import{vec2 as Oe}from"gl-matrix";function et(n,e,t){return(e[0]-n[0])*(e[1]+n[1])+(t[0]-e[0])*(t[1]+e[1])+(n[0]-t[0])*(n[1]+t[1])>=0}var _t=Oe.create(),Gt=Oe.create();function tt(n,e,t,r,s,o,a){return n[e++]=r,et(a[r],a[s],a[o])===t?(n[e++]=s,n[e++]=o):(n[e++]=o,n[e++]=s),e}function wt(n,e,t){return e>t?n>=e||n<t:n>=e&&n<t}function rt(n,e,t=0,r){let s=n.length;if(s<3)throw new Error(`Expected input polyline with 3 or more vertices, got ${s}`);let o=t+(s-2)*3;if(e?e.length<o&&(e.length=o):e=new Array(o),s===3)return e[t++]=0,e[t++]=1,e[t++]=2,[e,t];r===void 0&&(r=be(n));let a=Se(n),u=a[s-1],c=a[0],l=[a[0],a[1]];for(let h=2;h<s-1;h++){let b=a[h],m=l.length,y=l[m-1];if(wt(b,u,c)!==wt(y,u,c)){for(let p=0;p<m-1;p++)t=tt(e,t,r,b,l[p],l[p+1],n);l=[y,b]}else{let p=n[y],x=y;l.pop();let g=Oe.sub(Gt,p,n[b]);for(b===(x+1)%s!==r&&Oe.negate(g,g);l.length>0;){let V=l[l.length-1],E=n[V],P=Oe.sub(_t,E,p);if(g[0]*P[1]-g[1]*P[0]<=0)break;l.pop(),t=tt(e,t,r,b,x,V,n),x=V,p=E}l.push(x),l.push(b)}}let i=a[s-1],f=l.length-1;for(let h=0;h<f;h++)t=tt(e,t,r,i,l[h],l[h+1],n);return[e,t]}function st(n,e){let t=be(n),r=Ze(n,void 0,t),s=0;for(let a of r)s+=(a.length-2)*3;e?e.length<s&&(e.length=s):e=new Array(s);let o=0;for(let a of r)[e,o]=rt(a,e,o,t);return e}var Ct=Symbol(),q=U.create();function Ge(n,e,t){let[r,s,o]=e;Vt.set(n,s[0],s[1],s[2],0,r[0],r[1],r[2],0,o[0],o[1],o[2],0,t[0],t[1],t[2],1)}var Ve=class extends I{constructor(e,t,r,s){if(arguments.length===1&&Array.isArray(e)&&e.length===4&&e[0]===Ct){let d=e;super(d[1],d[2],d[3]);return}else if(arguments.length!==3&&arguments.length!==4)throw new Error("Unexpected number of arguments. Expected 3 or 4 arguments");let o=e,a=t,u=r,c=s,l=a.length,i=o.length;if(u.length!==l)throw new Error("There must be at least one frame per point");if(l<2)throw new Error("There must be at least 1 segment (2 points) in the curve");if(i<3)throw new Error("There must be at least 3 points in the polyline");let f=c?.startBaseUVs??null;if(f&&f.length!==i)throw new Error("Start base UV count must match polyline length");let h=c?.endBaseUVs??null;if(h&&h.length!==i)throw new Error("End base UV count must match polyline length");let b=!1,m=null,y=c?.segmentsUVs;if(y){let d=y[2];if(d){if(d.length!==i&&d.length!==i+1)throw new Error("Segments U count must match polyline length, or have 1 more for the wrap-around value")}else{d=new Array(i+1);for(let A=0;A<=i;A++)d[A]=A/i}b=d.length===i+1,m=[y[0]??0,y[1]??1,d]}let p=st(o),x=p.length,g=c?.smoothNormals??!1,V=i*l,E=V;g?E+=l:E*=2;let P=l-1,S=x/3,L=P*i*2,j=2*S+L,[R,te]=I.makeIndexBuffer(x),[B,ie]=I.makeIndexBuffer(x),[v,pe]=I.makeIndexBuffer(i*P*6),D=new Array(j),G=new Array(V);R.set(p);let le=0,k=i-1;for(let d=0;d<x;)D[le++]=[k-p[d++],k-p[d++],k-p[d++]];let re=i;g||(re*=2);let _=re;g&&b&&_++;let ce=0,se=_,H=0,ue=i,M=0;for(let d=0;d<P;d++){if(g)for(let A=0;A<re;A++){let C=ce+A,w=se+(A+1)%_;v[M++]=C,v[M++]=ce+(A+1)%_,v[M++]=w,v[M++]=C,v[M++]=w,v[M++]=se+A}else for(let A=0;A<re;A+=2){let C=ce+A,w=se+A,N=w+1;v[M++]=C,v[M++]=C+1,v[M++]=N,v[M++]=C,v[M++]=N,v[M++]=w}ce+=_,se+=_;for(let A=0;A<i;A++){let C=H+A,w=ue+(A+1)%i;D[le++]=[C,H+(A+1)%i,w],D[le++]=[C,w,ue+A]}H+=i,ue+=i}for(let d=0,A=0;d<x;){let C=p[d++],w=p[d++],N=p[d++];B[A++]=N,B[A++]=w,B[A++]=C,D[le++]=[k-N+H,k-w+H,k-C+H]}let ne=new WL.Mesh({vertexCount:i,indexData:R,indexType:te}),$=new WL.Mesh({vertexCount:E,indexData:v,indexType:pe}),X=new WL.Mesh({vertexCount:i,indexData:B,indexType:ie});super([[ne,c?.startMaterial??null],[$,c?.segmentMaterial??null],[X,c?.endMaterial??null]],{triVerts:D,vertPos:G});let Q=i*3,Y=ne.attribute(WL.MeshAttribute.Position);if(!Y)throw new Error("Could not get position mesh attribute accessor (start base mesh)");let z=new Float32Array(Q),K=ne.attribute(WL.MeshAttribute.Normal),T=null;K&&(T=new Float32Array(Q));let Le=i*2,me,Z=null;f&&(me=ne.attribute(WL.MeshAttribute.TextureCoordinate),me?Z=new Float32Array(Le):console.warn("Start base UVs ignored; texture coordinate mesh attribute not available"));let de=l*_*3,Te=$.attribute(WL.MeshAttribute.Position);if(!Te)throw new Error("Could not get position mesh attribute accessor (end base mesh)");let ge=new Float32Array(de),De=$.attribute(WL.MeshAttribute.Normal),O=null;De&&(O=new Float32Array(de));let Pe,J=null;m&&(Pe=$.attribute(WL.MeshAttribute.TextureCoordinate),Pe?J=new Float32Array(l*_*2):console.warn("End base UVs ignored; texture coordinate mesh attribute not available"));let Me=X.attribute(WL.MeshAttribute.Position);if(!Me)throw new Error("Could not get position mesh attribute accessor (end base mesh)");let ot=new Float32Array(Q),at=X.attribute(WL.MeshAttribute.Normal),ye=null;at&&(ye=new Float32Array(Q));let $e,ke=null;h&&($e=X.attribute(WL.MeshAttribute.TextureCoordinate),$e?ke=new Float32Array(Le):console.warn("End base UVs ignored; texture coordinate mesh attribute not available"));let kt=T||ye||O,fe=new Float32Array(j*2);M=0;let it=(S+L)*2;for(let d=0;M<x;M++)fe[d]=0,fe[it+d++]=2,fe[d]=M,fe[it+d++]=M;M=0;for(let d=S*2;M<L;M++)fe[d++]=1,fe[d++]=M;this.submeshMap=fe;let he=null,ee=null;if(kt){he=new Array(i),g&&(ee=new Array(i)),U.set(q,0,0,-1);let d=o[0],A=o[k],C=U.fromValues(d[0]-A[0],d[1]-A[1],0);he[k]=U.cross(C,q,C);for(let w=0;w<k;w++){let N=w+1,Ee=o[k-w],lt=o[k-N],Qe=U.fromValues(Ee[0]-lt[0],Ee[1]-lt[1],0);if(he[w]=U.cross(Qe,q,Qe),ee){let It=w===0?k:w-1,Ft=he[It],Ye=U.add(U.create(),Ft,Qe);U.normalize(Ye,Ye),ee[w]=Ye}}if(ee){let w=U.add(U.create(),he[k-1],he[k]);U.normalize(w,w),ee[k]=w}}let xe=Vt.create(),Ne=0;M=0;for(let d=0;d<l;d++){Ge(xe,u[d],a[d]),d>0&&(Ne+=U.distance(a[d],a[d-1]));for(let A=0;A<i;A++){let C=o[k-A],w=U.fromValues(C[0],C[1],0);U.transformMat4(w,w,xe),G[M++]=w}}Ge(xe,u[0],a[0]);let Xe=U.clone(u[0][2]);U.negate(Xe,Xe),M=0;let Ue=0;for(let d=0;d<i;d++)z.set(G[k-d],M),T&&T.set(Xe,M),Z&&(Z.set(f[d],Ue),Ue+=2),M+=3;let je=vt.create();M=0;let Re=0,Ae=0,_e=0;m&&(_e=m[1]-m[0]);for(let d=0;d<l;d++){Ge(xe,u[d],a[d]);let A=d*i;d>0&&(Re+=U.distance(a[d],a[d-1])),O&&vt.fromMat4(je,xe);for(let C=0;C<i;C++){if(ge.set(G[C+A],M),ee){if(O&&(U.transformMat3(q,ee[C],je),O.set(q,M)),J){let w=m[2][C],N=_e*Re/Ne;J.set([w,N],Ae),Ae+=2}}else{if(O&&(U.transformMat3(q,he[C],je),O.set(q,M),O.set(q,M+3)),J){let w=m[2][C],N;b?N=m[2][C+1]:N=m[2][(C+1)%i];let Ee=_e*Re/Ne;J.set([w,Ee,N,Ee],Ae),Ae+=4}M+=3,ge.set(G[(C+1)%i+A],M)}M+=3}if(ee&&b){if(ge.set(G[A],M),O&&(U.transformMat3(q,ee[0],je),O.set(q,M)),J){let C=m[2][i],w=_e*Re/Ne;J.set([C,w],Ae),Ae+=2}M+=3}}Ge(xe,u[P],a[P]);let Ut=u[P][2],Et=P*i;M=0,Ue=0;for(let d=0;d<i;d++)ot.set(G[Et+k-d],M),ye&&ye.set(Ut,M),ke&&(ke.set(h[d],Ue),Ue+=2),M+=3;Y.set(0,z),T&&K.set(0,T),Z&&me.set(0,Z),Te.set(0,ge),O&&De.set(0,O),J&&Pe.set(0,J),Me.set(0,ot),ye&&at.set(0,ye),ke&&$e.set(0,ke)}clone(e){return new Ve([Ct,[[this.submeshes[0][0],e?.startMaterial??null],[this.submeshes[1][0],e?.segmentMaterial??null],[this.submeshes[2][0],e?.endMaterial??null]],this.premadeManifoldMesh,this.submeshMap])}};var Wt=class extends Ve{constructor(e,t,r){let s=[[0,0,0],[0,0,t]],o=t>=0?[[0,1,0],[-1,0,0],[0,0,1]]:[[0,1,0],[1,0,0],[0,0,-1]],a=[o,o];super(e,s,a,r)}};function We(n,e,t,r=null,s=null,o=null){if("primitive"in t)switch(t.primitive){case"cube":case"cylinder":case"sphere":case"tetrahedron":s&&s(n,e,t);break;default:{let a=t.primitive;throw new Error(`Unknown primitive: ${a}`)}}else if("operation"in t)switch(t.operation){case"add":case"union":case"subtract":case"difference":case"intersect":case"intersection":{if("manifolds"in t)for(let a=t.manifolds.length-1;a>=0;a--)We(t.manifolds,a,t.manifolds[a],r,s,o);else We(t,"right",t.right,r,s,o),We(t,"left",t.left,r,s,o);o&&o(n,e,t);break}case"translate":case"rotate":case"scale":case"transform":case"refine":case"asOriginal":We(t,"manifold",t.manifold,r,s,o);case"extrude":case"revolve":o&&o(n,e,t);break;default:{let a=t.operation;throw a==="compose"||a==="decompose"?new Error(`${a} operation is not implemented yet`):new Error(`Unknown operation: ${a}`)}}else r&&r(n,e,t)}function Lt(n,e=null,t=null,r=null,s=null){let o={root:n};if("primitive"in n)t&&t(o,"root",n);else switch(n.operation){case"isEmpty":case"numVert":case"numTri":case"numEdge":case"boundingBox":case"precision":case"genus":case"getProperties":case"getCurvature":case"originalID":We(n,"manifold",n.manifold,e,t,r),s&&s(o,"root",n);break;default:We(o,"root",n,e,t,r)}}import{vec3 as F}from"gl-matrix";function Pt(n,e,t,r,s,o,a,u){let c=u.get(e),l=u.get(t),i=u.get(r),f=new Array(n),h=new Array(n),b=new Array(n);for(let m=0;m<n;m++)f[m]=c[m]*s[0]+l[m]*s[1]+i[m]*s[2],b[m]=c[m]*o[0]+l[m]*o[1]+i[m]*o[2],h[m]=c[m]*a[0]+l[m]*a[1]+i[m]*a[2];return[f,b,h]}function nt(n,e,t,r,s,o,a,u,c,l){let[i,f,h]=Pt(e,t,r,s,o,a,u,c);l.set(i,n),n+=e,l.set(f,n),n+=e,l.set(h,n)}var Tt=class{constructor(e=null,t="manifold-wle.worker.min.js",r="manifold.js"){this.workers=null;this.nextJobID=0;this.jobs=new Map;this.wantedWorkerCount=Math.max(1,e??Math.ceil(navigator.hardwareConcurrency/2)),this.workerPath=t,this.libraryPath=r}toManifoldMesh(e){return e instanceof I?e.manifoldMesh:e instanceof WL.Mesh?I.manifoldFromWLE(e,!1):e}meshToWLEArr(e,t,r){let s=e.triVerts.length;if(s===0)return[];let o=new Map,a=0;for(;a<s;a++){let c=t.triBary[a],l=r.get(c.originalID),i,f,h=a;l instanceof I?[[i,f],h]=l.getTriBarySubmesh(c.tri):(f=null,i=l);let b=o.get(f);b||(b=new Map,o.set(f,b));let m=b.get(i);m||(m=[],b.set(i,m)),m.push([a,h])}let u=[];for(let[c,l]of o){let i=0;for(let v of l.values())i+=v.length;let f=i*3,[h,b]=I.makeIndexBuffer(f);for(let v=0;v<f;v++)h[v]=v;let m=new WL.Mesh({vertexCount:f,indexType:b,indexData:h}),y=m.attribute(WL.MeshAttribute.Position),p=m.attribute(WL.MeshAttribute.Tangent),x=m.attribute(WL.MeshAttribute.Normal),g=m.attribute(WL.MeshAttribute.TextureCoordinate),V=m.attribute(WL.MeshAttribute.Color),E=p||x||g||V,P=new Float32Array(f*3),S;p&&(S=new Float32Array(f*4));let L;x&&(L=new Float32Array(f*3));let j;g&&(j=new Float32Array(f*2));let R;V&&(R=new Float32Array(f*4));let te=0,B=0,ie=0;for(let[v,pe]of l){let D=pe.length;for(let G=0;G<D;G++,te+=6,B+=9,ie+=12){let[le,k]=pe[G],re=e.triVerts[le],_=t.triBary[le],ce=e.vertPos[re[0]],se=e.vertPos[re[1]],H=e.vertPos[re[2]];if(E&&v){let ue=_.vertBary[0],M=_.vertBary[1],ne=_.vertBary[2],$;ue<0?$=[[1,0,0],[0,1,0],[0,0,1]][ue+3]:$=t.barycentric[ue];let X;M<0?X=[[1,0,0],[0,1,0],[0,0,1]][M+3]:X=t.barycentric[M];let Q;ne<0?Q=[[1,0,0],[0,1,0],[0,0,1]][ne+3]:Q=t.barycentric[ne];let Y,z,K;if(v.indexData){let T=k*3;Y=v.indexData[T++],z=v.indexData[T++],K=v.indexData[T]}else Y=k*3,z=Y+1,K=z+1;if(S){let T=v.attribute(WL.MeshAttribute.Tangent);T&&nt(ie,4,Y,z,K,$,X,Q,T,S)}if(L){let T=v.attribute(WL.MeshAttribute.Position),Le=v.attribute(WL.MeshAttribute.Normal);if(T&&Le){let[me,Z,de]=Pt(3,Y,z,K,$,X,Q,Le),Te=T.get(z),ge=F.sub(F.create(),Te,T.get(Y)),De=F.sub(F.create(),T.get(K),Te),O=F.cross(F.create(),ge,De);F.normalize(O,O);let Pe=F.sub(F.create(),se,ce),J=F.sub(F.create(),H,se),Me=F.cross(F.create(),Pe,J);F.normalize(Me,Me),F.dot(O,Me)<0&&(F.negate(me,me),F.negate(Z,Z),F.negate(de,de)),L.set(me,B),L.set(Z,B+3),L.set(de,B+6)}}if(j){let T=v.attribute(WL.MeshAttribute.TextureCoordinate);T&&nt(te,2,Y,z,K,$,X,Q,T,j)}if(R){let T=v.attribute(WL.MeshAttribute.Color);T&&nt(ie,4,Y,z,K,$,X,Q,T,R)}}P.set(ce,B),P.set(se,B+3),P.set(H,B+6)}}y.set(0,P),S&&p.set(0,S),L&&x.set(0,L),j&&g.set(0,j),R&&V.set(0,R),u.push([m,c])}return u}async initializeSingle(e){let t=new Worker(this.workerPath,{name:`manifold-worker-${e}`});return new Promise((r,s)=>{let o=0;t.onmessage=a=>{switch(a.data.type){case"created":o===0&&(o++,t.postMessage({type:"initialize",libraryPath:this.libraryPath}));break;case"ready":o===1&&(o++,r(),this.workers.push([t,0]));break;case"terminated":if(this.workers){for(let[u,[c,l]]of this.workers.entries())if(c===t){this.workers.splice(u,1);break}}t.terminate(),s();break;case"result":{let u=this.jobs.get(a.data.jobID);if(!u){console.warn(`Ignored invalid job ID (${a.data.jobID})`);break}let[c,l,i]=u;if(a.data.success){let f=a.data.result;if(Array.isArray(f)){let[h,b,m]=f,y=new Map;for(let[p,x]of m){let g=i[x];g&&y.set(p,g)}c(this.meshToWLEArr(h,b,y))}else c(f)}else l(a.data.error);break}default:console.warn("Unexpected message from worker:",a.data)}}})}async initialize(){this.workers=[];let e=new Array;for(let t=0;t<this.wantedWorkerCount;t++)e.push(this.initializeSingle(t));if(await Promise.allSettled(e),this.workers.length===0)throw new Error("No worker was successfuly created")}getBestWorker(){let e=this.workers,t=e[0];for(let r=1;r<e.length;r++){let s=e[r];s[1]<t[1]&&(t=s)}return t}async dispatch(e){if(this.workers||await this.initialize(),this.workers.length===0)throw new Error("All workers failed to initialize");let t=0,r=new Map,s=new Array;Lt(e,(u,c,l)=>{let i=this.toManifoldMesh(l);r.set(t,l),u[c]=[t++,i],s.push(l)});let o=this.getBestWorker();o[1]++;let a=this.nextJobID++;return await new Promise((u,c)=>{this.jobs.set(a,[u,c,s]),o[0].postMessage({type:"operation",jobID:a,operation:e})})}};var Be=class extends I{static fromWLEMesh(e,t){return new Be([e,t])}addSubmesh(e,t){return this.submeshes.push([e,t]),this.submeshCount-1}clone(e){let t=new Array(this.submeshCount);for(let r=0;r<this.submeshCount;r++){let s=this.submeshes[r];e?t[r]=[s[0],e[r]]:t[r]=[s[0],s[1]]}return new Be(t)}};export{I as BaseManifoldWLMesh,Mt as CubeMesh,Ve as ExtrusionMesh,Wt as LinearExtrusionMesh,Tt as ManifoldPool,Be as ManifoldWLMesh,Ce as RectangularCuboidMesh,Yt as makeCirclePolyline,Kt as makeCubePolyline,Zt as makeRectanglePolyline,ct as makeRegularPolyline,or as makeRotationMinimizingFrames,rr as makeStarPolyline};
//# sourceMappingURL=index.esm.min.js.map
