function O(l,t,e,r=null,o=null,n=null){if("primitive"in e)switch(e.primitive){case"cube":case"cylinder":case"sphere":case"tetrahedron":o&&o(l,t,e);break;default:{let i=e.primitive;throw new Error(`Unknown primitive: ${i}`)}}else if("operation"in e)switch(e.operation){case"add":case"union":case"subtract":case"difference":case"intersect":case"intersection":{if("manifolds"in e)for(let i=e.manifolds.length-1;i>=0;i--)O(e.manifolds,i,e.manifolds[i],r,o,n);else O(e,"right",e.right,r,o,n),O(e,"left",e.left,r,o,n);n&&n(l,t,e);break}case"translate":case"rotate":case"scale":case"transform":case"refine":case"asOriginal":O(e,"manifold",e.manifold,r,o,n);case"extrude":case"revolve":n&&n(l,t,e);break;default:{let i=e.operation;throw i==="compose"||i==="decompose"?new Error(`${i} operation is not implemented yet`):new Error(`Unknown operation: ${i}`)}}else r&&r(l,t,e)}function ie(l,t=null,e=null,r=null,o=null){let n={root:l};if("primitive"in l)e&&e(n,"root",l);else switch(l.operation){case"isEmpty":case"numVert":case"numTri":case"numEdge":case"boundingBox":case"precision":case"genus":case"getProperties":case"getCurvature":case"originalID":O(l,"manifold",l.manifold,t,e,r),o&&o(n,"root",l);break;default:O(n,"root",l,t,e,r)}}var D=class{constructor(){this.buckets=new Map}murmur_32_scramble(t){return t*=3432918353,t=t<<15|t>>17,t*=461845907,t&4294967295}murmur3_32(t,e){let r=e,o=new Uint32Array(t.buffer);for(let n of o)r^=this.murmur_32_scramble(n),r=r<<13&4294967295|r>>19,r=r*5+3864292196&4294967295;return r^=o.byteLength,r^=r>>16,r=r*2246822507&4294967295,r^=r>>13,r=r*3266489909&4294967295,r^=r>>16,r}getHash(t){return this.murmur3_32(t,3935228948)}isUnique(t){let e=this.getHash(t),r=this.buckets.get(e);if(r){for(let o of r)if(t[0]===o[0]&&t[1]===o[1]&&t[2]===o[2])return!1;r.push(t)}else this.buckets.set(e,[t]);return!0}clear(){this.buckets.clear()}};import{vec3 as m}from"gl-matrix";function ae(l,t,e,r,o,n,i,c){let p=c.get(t),u=c.get(e),b=c.get(r),h=new Array(l),f=new Array(l),s=new Array(l);for(let a=0;a<l;a++)h[a]=p[a]*o[0]+u[a]*o[1]+b[a]*o[2],s[a]=p[a]*n[0]+u[a]*n[1]+b[a]*n[2],f[a]=p[a]*i[0]+u[a]*i[1]+b[a]*i[2];return[h,s,f]}function Y(l,t,e,r,o,n,i,c,p,u){let[b,h,f]=ae(t,e,r,o,n,i,c,p);u.set(b,l),u.set(h,l+3),u.set(f,l+6)}var ne=class{constructor(t=null,e="manifold-wle.worker.min.js",r="manifold.js"){this.workers=null;this.nextJobID=0;this.jobs=new Map;this.wantedWorkerCount=Math.max(1,t??Math.ceil(navigator.hardwareConcurrency/2)),this.workerPath=e,this.libraryPath=r}meshFromWLE(t){let e=t.indexData,r=t.vertexCount,o=e===null?r:e.length;if(o%3!==0)throw new Error(`Mesh has an invalid vertex count (${o}). Must be a multiple of 3`);let n=t.attribute(WL.MeshAttribute.Position),i=o/3,c={vertPos:new Array,triVerts:new Array(i)},p=new D,u=new Array,b=0;for(let s=0;s<r;s++){let a=n.get(s);if(p.isUnique(a))c.vertPos.push(a),u.push(b++);else{let[g,y,C]=a,w=0;for(;w<c.vertPos.length;w++){let[A,T,P]=c.vertPos[w];if(A===g&&T===y&&P===C)break}w===c.vertPos.length?(c.vertPos.push(a),u.push(b++)):u.push(w)}}let h=0,f=new Array(i);if(e===null)for(let s=0;s<o;s+=3)f[h]=[s,s+1,s+2],c.triVerts[h++]=[u[s],u[s+1],u[s+2]];else for(let s=0;s<o;){let a=e[s++],g=e[s++],y=e[s++];f[h]=[a,g,y],c.triVerts[h++]=[u[a],u[g],u[y]]}return[c,f]}meshToWLEArr(t,e,r,o,n){let i=t.triVerts.length;if(i===0)return[];let c=new Map,p=0;for(;p<i;p++){let b=r.triBary[p],h=o.get(b.originalID),f=n.get(h)??null,s=c.get(f);s||(s=[],c.set(f,s)),s.push(p)}let u=[];for(let[b,h]of c){let f=h.length,s=f*3,a,g;s<=255?(a=WL.MeshIndexType.UnsignedByte,g=new Uint8Array(s)):s<=65535?(a=WL.MeshIndexType.UnsignedShort,g=new Uint16Array(s)):(a=WL.MeshIndexType.UnsignedInt,g=new Uint32Array(s));for(let x=0;x<s;x++)g[x]=x;let y=new WL.Mesh({vertexCount:s,indexType:a,indexData:g}),C=y.attribute(WL.MeshAttribute.Position),w=y.attribute(WL.MeshAttribute.Tangent),A=y.attribute(WL.MeshAttribute.Normal),T=y.attribute(WL.MeshAttribute.TextureCoordinate),P=y.attribute(WL.MeshAttribute.Color),ce=w||A||T||P,E=new Float32Array(s*3),I;w&&(I=new Float32Array(s*4));let W;A&&(W=new Float32Array(s*3));let j;T&&(j=new Float32Array(s*2));let G;P&&(G=new Float32Array(s*4));for(let x=0,Z=0,d=0,N=0;x<f;x++,Z+=6,d+=9,N+=16){let ee=h[x],z=t.triVerts[ee],F=r.triBary[ee],k=o.get(F.originalID),re=t.vertPos[z[0]],_=t.vertPos[z[1]],te=t.vertPos[z[2]];if(ce&&k&&k instanceof WL.Mesh){let ue=e.get(k),$=F.vertBary[0],J=F.vertBary[1],R=F.vertBary[2],v;$<0?v=[[1,0,0],[0,1,0],[0,0,1]][$+3]:v=r.barycentric[$];let L;J<0?L=[[1,0,0],[0,1,0],[0,0,1]][J+3]:L=r.barycentric[J];let V;R<0?V=[[1,0,0],[0,1,0],[0,0,1]][R+3]:V=r.barycentric[R];let[S,B,U]=ue[F.tri];if(I){let M=k.attribute(WL.MeshAttribute.Tangent);M&&Y(N,4,S,B,U,v,L,V,M,I)}if(W){let M=k.attribute(WL.MeshAttribute.Position),se=k.attribute(WL.MeshAttribute.Normal);if(M&&se){let[q,H,K]=ae(3,S,B,U,v,L,V,se),oe=M.get(B),le=m.sub(m.create(),oe,M.get(S)),fe=m.sub(m.create(),M.get(U),oe),Q=m.cross(m.create(),le,fe);m.normalize(Q,Q);let pe=m.sub(m.create(),_,re),he=m.sub(m.create(),te,_),X=m.cross(m.create(),pe,he);m.normalize(X,X),m.dot(Q,X)<0&&(m.negate(q,q),m.negate(H,H),m.negate(K,K)),W.set(q,d),W.set(H,d+3),W.set(K,d+6)}}if(j){let M=k.attribute(WL.MeshAttribute.Tangent);M&&Y(Z,2,S,B,U,v,L,V,M,j)}if(G){let M=k.attribute(WL.MeshAttribute.Color);M&&Y(N,4,S,B,U,v,L,V,M,G)}}E.set(re,d),E.set(_,d+3),E.set(te,d+6)}C.set(0,E),I&&w.set(0,I),W&&A.set(0,W),j&&T.set(0,j),G&&P.set(0,G),u.push([y,b])}return u}async initializeSingle(t){let e=new Worker(this.workerPath,{name:`manifold-worker-${t}`});return new Promise((r,o)=>{let n=0;e.onmessage=i=>{switch(i.data.type){case"created":n===0&&(n++,e.postMessage({type:"initialize",libraryPath:this.libraryPath}));break;case"ready":n===1&&(n++,r(),this.workers.push([e,0]));break;case"terminated":if(this.workers){for(let[c,[p,u]]of this.workers.entries())if(p===e){this.workers.splice(c,1);break}}e.terminate(),o();break;case"result":{let c=this.jobs.get(i.data.jobID);if(!c){console.warn(`Ignored invalid job ID (${i.data.jobID})`);break}let[p,u,b,h,f]=c;if(i.data.success){let s=i.data.result;if(Array.isArray(s)){let[a,g,y]=s,C=new Map;for(let[w,A]of y){let T=b[A];T&&C.set(w,T)}p(this.meshToWLEArr(a,f,g,C,h))}else p(s)}else u(i.data.error);break}default:console.warn("Unexpected message from worker:",i.data)}}})}async initialize(){this.workers=[];let t=new Array;for(let e=0;e<this.wantedWorkerCount;e++)t.push(this.initializeSingle(e));if(await Promise.allSettled(t),this.workers.length===0)throw new Error("No worker was successfuly created")}getBestWorker(){let t=this.workers,e=t[0];for(let r=1;r<t.length;r++){let o=t[r];o[1]<e[1]&&(e=o)}return e}async dispatch(t,e){if(this.workers||await this.initialize(),this.workers.length===0)throw new Error("All workers failed to initialize");let r=0,o=new Map,n=new Array,i=new Map;ie(t,(b,h,f)=>{let s=f;if(f instanceof WL.Mesh){let a;[s,a]=this.meshFromWLE(f),i.set(f,a)}o.set(r,f),b[h]=[r++,s],n.push(f)});let c=this.getBestWorker();c[1]++;let p=this.nextJobID++,u=new Map(e?.entries());return await new Promise((b,h)=>{this.jobs.set(p,[b,h,n,u,i]),c[0].postMessage({type:"operation",jobID:p,operation:t})})}};export{ne as ManifoldPool};
//# sourceMappingURL=index.esm.min.js.map
