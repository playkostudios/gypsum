{
  "version": 3,
  "sources": ["../src/client/polylines/regular-polyline.ts", "../src/client/polylines/circle-polyline.ts", "../src/client/polylines/cube-polyline.ts", "../src/client/polylines/rectangle-polyline.ts", "../src/client/polylines/star-polyline.ts", "../src/client/rmf/make-rotation-minimizing-frames.ts", "../src/client/BaseManifoldWLMesh.ts", "../src/client/VertexHasher.ts", "../src/client/RectangularCuboidMesh.ts", "../src/client/CubeMesh.ts", "../src/client/ExtrusionMesh.ts", "../src/client/triangulation/is-clockwise-2d-polygon.ts", "../src/client/triangulation/sort-2d-indices.ts", "../src/client/triangulation/split-2d-polygon.ts", "../src/client/triangulation/partition-2d-polygon.ts", "../src/client/triangulation/triangulate-monotone-2d-polygon.ts", "../src/client/triangulation/is-clockwise-2d-triangle.ts", "../src/client/triangulation/triangulate-2d-polygon.ts", "../src/client/LinearExtrusionMesh.ts", "../src/common/iterate-operation-tree.ts", "../src/client/ManifoldPool.ts", "../src/client/ManifoldWLMesh.ts"],
  "sourcesContent": ["import { vec2 } from 'gl-matrix';\n\nconst TAU = Math.PI * 2;\n\nexport function makeRegularPolyline(radius: number, sides: number, clockwise = false): Array<vec2> {\n    if (sides < 3) {\n        throw new Error('There must be at least 3 sides in a regular polyline');\n    }\n\n    const polyline = new Array(sides);\n    const sidesM1 = sides - 1;\n\n    for (let i = 0; i < sides; i++) {\n        const j = clockwise ? i : (sidesM1 - i);\n        const angle = TAU * j / sides;\n        const y = Math.cos(angle) * radius;\n        const x = Math.sin(angle) * radius;\n        polyline[i] = vec2.fromValues(x, y);\n    }\n\n    return polyline;\n}", "import { makeRegularPolyline } from './regular-polyline';\n\nimport type { vec2 } from 'gl-matrix';\n\nexport function makeCirclePolyline(radius: number, clockwise = false, subDivisions = 12): Array<vec2> {\n    return makeRegularPolyline(radius, subDivisions, clockwise);\n}", "import { vec2 } from 'gl-matrix';\n\nexport function makeCubePolyline(length: number, clockwise = false): Array<vec2> {\n    const half = length / 2;\n    return clockwise ? [\n        vec2.fromValues(half, half), vec2.fromValues(half, -half),\n        vec2.fromValues(-half, -half), vec2.fromValues(-half, half)\n    ] : [\n        vec2.fromValues(half, half), vec2.fromValues(-half, half),\n        vec2.fromValues(-half, -half), vec2.fromValues(half, -half)\n    ];\n}", "import { vec2 } from 'gl-matrix';\n\nexport function makeRectanglePolyline(width: number, height: number, clockwise = false): Array<vec2> {\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    return clockwise ? [\n        vec2.fromValues(halfWidth, halfHeight), vec2.fromValues(halfWidth, -halfHeight),\n        vec2.fromValues(-halfWidth, -halfHeight), vec2.fromValues(-halfWidth, halfHeight)\n    ] : [\n        vec2.fromValues(halfWidth, halfHeight), vec2.fromValues(-halfWidth, halfHeight),\n        vec2.fromValues(-halfWidth, -halfHeight), vec2.fromValues(halfWidth, -halfHeight)\n    ];\n}", "import { vec2 } from 'gl-matrix';\n\nconst TAU = Math.PI * 2;\n\nexport function makeStarPolyline(outerRadius: number, innerRadius: number, sides: number, clockwise = false): Array<vec2> {\n    if (sides < 3) {\n        throw new Error('There must be at least 3 sides in a star polyline');\n    }\n\n    const polyline = new Array(sides * 2);\n    const sidesM1 = sides - 1;\n    const halfAngle = TAU / sides / 2;\n    let k = 0;\n\n    for (let i = 0; i < sides; i++) {\n        const j = clockwise ? i : (sidesM1 - i);\n\n        const outerAngle = TAU * j / sides;\n        const outerY = Math.cos(outerAngle) * outerRadius;\n        const outerX = Math.sin(outerAngle) * outerRadius;\n        const outerPos = vec2.fromValues(outerX, outerY);\n\n        const innerAngle = outerAngle + halfAngle;\n        const innerY = Math.cos(innerAngle) * innerRadius;\n        const innerX = Math.sin(innerAngle) * innerRadius;\n        const innerPos = vec2.fromValues(innerX, innerY);\n\n        if (clockwise) {\n            polyline[k++] = outerPos;\n            polyline[k++] = innerPos;\n        } else {\n            polyline[k++] = innerPos;\n            polyline[k++] = outerPos;\n        }\n    }\n\n    return polyline;\n}", "import { quat, vec3 } from 'gl-matrix';\n\nconst HALF_PI = Math.PI / 2;\nconst TAU = Math.PI * 2;\nconst tq0 = quat.create();\nconst tv0 = vec3.create();\nconst tv1 = vec3.create();\nconst tv2 = vec3.create();\n\nimport type { CurveFrames } from './curve-frame';\n\nexport interface RMFOptions {\n    // end boundary condition for the RMF curve; the up direction at the end of\n    // the curve\n    endNormal?: vec3;\n    // how many twists should be added to the curve. 0 by default\n    twists?: number;\n}\n\nexport function makeRotationMinimizingFrames(positions: Array<vec3>, tangents: Array<vec3>, startNormal: vec3, options?: RMFOptions): CurveFrames {\n    // XXX startNormal should be a unit vector pointing up, or if the start is\n    // rotated, then the rotated up unit vector\n\n    // validate curve\n    const pointCount = positions.length;\n\n    if (tangents.length < pointCount) {\n        throw new Error('There must be at least one tangent per point');\n    }\n\n    if (pointCount < 2) {\n        throw new Error('There must be at least 1 segment (2 points) in the curve');\n    }\n\n    // compute rotation minimizing frames. using method from this paper:\n    // https://www.microsoft.com/en-us/research/publication/computation-rotation-minimizing-frames/\n    const frames: CurveFrames = new Array(pointCount);\n    const startTangent = tangents[0];\n    const startBinormal = vec3.cross(vec3.create(), startTangent, startNormal);\n    // first frame = (r,s,t); r = normal, s = binormal, t = tangent\n    frames[0] = [startNormal, startBinormal, startTangent];\n\n    for (let i = 0; i < pointCount - 1; i++) {\n        const v_1 = vec3.sub(tv0, positions[i + 1], positions[i]);\n        const c_1 = vec3.dot(v_1, v_1);\n        const r_i = frames[i][0];\n        const t_i = frames[i][2];\n        const temp = -2 / c_1;\n        const r_L_i = vec3.scaleAndAdd(tv1, r_i, v_1, vec3.dot(v_1, r_i) * temp);\n        const t_L_i = vec3.scaleAndAdd(tv2, t_i, v_1, vec3.dot(v_1, t_i) * temp);\n\n        const t_i1 = tangents[i + 1];\n\n        const v_2 = vec3.sub(tv2, t_i1, t_L_i);\n        const c_2 = vec3.dot(v_2, v_2);\n        const r_i1 = vec3.scaleAndAdd(vec3.create(), r_L_i, v_2, vec3.dot(v_2, r_L_i) * -2 / c_2);\n        const s_i1 = vec3.cross(vec3.create(), t_i1, r_i1);\n\n        frames[i + 1] = [r_i1, s_i1, t_i1];\n    }\n\n    const endNormal = options?.endNormal;\n    const twists = options?.twists ?? 0;\n    if (endNormal || twists > 0) {\n        let angleErr = 0;\n\n        if (endNormal) {\n            // end normal included. calculate the error between the computed\n            // normal in the last frame and the wanted normal. convert it to an\n            // angle.\n\n            // this is an extension to the algorithm described in the same paper\n            // as before (section 6.3: variational principles for rmf with\n            // boundary conditions)\n\n            const endTangent = tangents[pointCount - 1];\n            const endBinormal = vec3.cross(vec3.create(), endTangent, endNormal);\n            const actualNormal = frames[pointCount - 1][0];\n\n            const dx = vec3.dot(endBinormal, actualNormal);\n            const dy = vec3.dot(endNormal, actualNormal);\n\n            if (dx !== 0 && dy !== 0) {\n                angleErr = Math.atan2(dy, dx) - HALF_PI;\n            }\n        }\n\n        angleErr += TAU * twists;\n\n        if (angleErr !== 0) {\n            // divide the angle evenly along the curve (angular speed). apply\n            // the angular speed to the whole curve\n            // XXX the technique's article uses a curvature value that is\n            // calculated from the second differential of the curve, however, we\n            // are estimating it by getting the length of each segment instead.\n            // the more segments there are, the more accurate the curvature\n            // value is\n            let totalLength = 0;\n            let lastPos = positions[0];\n            for (let i = 1; i < pointCount; i++) {\n                const curPos = positions[i];\n                totalLength += vec3.distance(lastPos, curPos);\n                lastPos = curPos;\n            }\n\n            let interpLength = 0;\n            lastPos = positions[0];\n            for (let i = 1; i < pointCount; i++) {\n                const [r, s, _t] = frames[i];\n                const curPos = positions[i];\n                interpLength += vec3.distance(lastPos, curPos);\n                lastPos = curPos;\n\n                const thisAngleErr = angleErr * interpLength / totalLength;\n                quat.setAxisAngle(tq0, tangents[i], thisAngleErr);\n                vec3.transformQuat(r, r, tq0);\n                vec3.transformQuat(s, s, tq0);\n            }\n        }\n    }\n\n    return frames;\n}", "// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path=\"../../types/globals.d.ts\" />\n\nimport { vec3 } from 'gl-matrix';\nimport VertexHasher from './VertexHasher';\n\nconst MAX_INDEX_BUFFER_SIZE = 4294967296;\nconst temp0 = vec3.create();\nconst temp1 = vec3.create();\n\n/**\n * Maps a manifold triangle index to a WLE submesh index. The format is:\n * [0]: submesh index of manifold triangle 0\n * [1]: triangle index of manifold triangle 0\n * [2]: submesh index of manifold triangle 1\n * [3]: triangle index of manifold triangle 1\n * ...\n * [2n]: submesh index of manifold triangle n\n * [2n + 1]: triangle index of manifold triangle n\n */\nexport type SubmeshMap = Float32Array;\n\nexport type Submesh = [mesh: WL.Mesh, material: WL.Material];\n\nexport abstract class BaseManifoldWLMesh {\n    /**\n     * WARNING: the submeshes array and the manifold mesh will have their\n     * ownership tranferred to this object. if you modify them later, they will\n     * be modified here as well, possibly corrupting the mesh. to avoid issues\n     * with this, do a deep clone of the inputs\n     */\n    constructor(protected submeshes: Array<Submesh> = [], protected premadeManifoldMesh?: Mesh, protected submeshMap?: SubmeshMap) {}\n\n    get manifoldMesh(): Mesh {\n        if (!this.premadeManifoldMesh) {\n            const wleMeshes = new Array<WL.Mesh>(this.submeshes.length);\n\n            let i = 0;\n            for (const [wleMesh, _material] of this.submeshes) {\n                wleMeshes[i++] = wleMesh;\n            }\n\n            [this.submeshMap, this.premadeManifoldMesh] = BaseManifoldWLMesh.manifoldFromWLE(wleMeshes);\n        }\n\n        return this.premadeManifoldMesh;\n    }\n\n    abstract clone(): BaseManifoldWLMesh;\n\n    get submeshCount(): number {\n        return this.submeshes.length;\n    }\n\n    getSubmesh(submeshIdx: number): Submesh {\n        const submesh = this.submeshes[submeshIdx];\n\n        if (!submesh) {\n            throw new Error(`No submesh exists at index ${submeshIdx}`);\n        }\n\n        return submesh;\n    }\n\n    getSubmeshes(): Array<Submesh> {\n        const submeshes = new Array(this.submeshCount);\n\n        for (let i = 0; i < this.submeshCount; i++) {\n            const submesh = this.submeshes[i];\n            submeshes[i] = [submesh[0], submesh[1]];\n        }\n\n        return submeshes;\n    }\n\n    getTriBarySubmesh(triIdx: number): [submesh: Submesh, iTriOrig: number] {\n        if (!this.submeshMap) {\n            throw new Error('Missing submesh map');\n        }\n\n        const offset = triIdx * 2;\n        return [\n            this.getSubmesh(this.submeshMap[offset]),\n            this.submeshMap[offset + 1]\n        ];\n    }\n\n    static manifoldToWLE(mesh: Mesh): WL.Mesh {\n        // XXX only for debugging, hence the inneficient non-indexed vertices\n        // (works with MeshVisualizer)\n        const triCount = mesh.triVerts.length;\n        const indexCount = triCount * 3;\n        const indexData = new Uint32Array(indexCount);\n\n        for (let i = 0; i < indexCount; i++) {\n            indexData[i] = i;\n        }\n\n        const wleMesh = new WL.Mesh({ indexData, indexType: WL.MeshIndexType.UnsignedInt, vertexCount: indexCount });\n\n        const positions = wleMesh.attribute(WL.MeshAttribute.Position);\n        const normals = wleMesh.attribute(WL.MeshAttribute.Normal);\n\n        let j = 0;\n        for (let i = 0; i < triCount; i++) {\n            const tri = mesh.triVerts[i];\n\n            const a = tri[0];\n            const b = tri[1];\n            const c = tri[2];\n            const aPos = mesh.vertPos[a];\n            const bPos = mesh.vertPos[b];\n            const cPos = mesh.vertPos[c];\n\n            if (normals) {\n                if (mesh.vertNormal) {\n                    normals.set(j, mesh.vertNormal[a]);\n                    normals.set(j + 1, mesh.vertNormal[b]);\n                    normals.set(j + 2, mesh.vertNormal[c]);\n                } else {\n                    // calculate triangle plane normal\n                    vec3.sub(temp0, bPos, aPos); // BA\n                    vec3.sub(temp1, bPos, cPos); // BC\n                    vec3.cross(temp0, temp1, temp0); // normal\n\n                    normals.set(j, temp0);\n                    normals.set(j + 1, temp0);\n                    normals.set(j + 2, temp0);\n                }\n            }\n\n            positions.set(j++, aPos);\n            positions.set(j++, bPos);\n            positions.set(j++, cPos);\n        }\n\n        return wleMesh;\n    }\n\n    static manifoldFromWLE(wleMeshes: WL.Mesh | Array<WL.Mesh>): [submeshMap: SubmeshMap, manifoldMesh: Mesh];\n    static manifoldFromWLE(wleMeshes: WL.Mesh | Array<WL.Mesh>, genSubmeshMap: true): [submeshMap: SubmeshMap, manifoldMesh: Mesh];\n    static manifoldFromWLE(wleMeshes: WL.Mesh | Array<WL.Mesh>, genSubmeshMap: false): Mesh;\n    static manifoldFromWLE(wleMeshes: WL.Mesh | Array<WL.Mesh>, genSubmeshMap = true): Mesh | [submeshMap: SubmeshMap, manifoldMesh: Mesh] {\n        if (!Array.isArray(wleMeshes)) {\n            wleMeshes = [wleMeshes];\n        }\n\n        // try to make manifold from mesh. this will fail if there are\n        // disconnected faces that have edges with the same position (despite\n        // being different edges)\n        // validate vertex count\n        let totalVertexCount = 0;\n\n        for (const wleMesh of wleMeshes) {\n            const packedVertexCount = wleMesh.vertexCount;\n            const indexData = wleMesh.indexData;\n            const vertexCount = indexData === null ? packedVertexCount : indexData.length;\n\n            if (vertexCount % 3 !== 0) {\n                throw new Error(`Mesh has an invalid vertex count (${vertexCount}). Must be a multiple of 3`);\n            }\n\n            totalVertexCount += vertexCount;\n        }\n\n        const totalTriCount = totalVertexCount / 3;\n        const mesh = {\n            vertPos: new Array<Vec3>(),\n            triVerts: new Array<Vec3>(totalTriCount)\n        }\n        const hasher = new VertexHasher();\n        const submeshMap = genSubmeshMap ? new Float32Array(totalTriCount * 2) : null;\n        let jm = 0;\n        let js = 0;\n\n        for (let submeshIdx = 0; submeshIdx < wleMeshes.length; submeshIdx++) {\n            // prepare accessors\n            const wleMesh = wleMeshes[submeshIdx];\n            const positions = wleMesh.attribute(WL.MeshAttribute.Position);\n            const packedVertexCount = wleMesh.vertexCount;\n            const indexData = wleMesh.indexData;\n            const vertexCount = indexData === null ? packedVertexCount : indexData.length;\n\n            // convert positions\n            const mergedIndices = new Array<number>();\n            for (let i = 0; i < packedVertexCount; i++) {\n                const pos = positions.get(i);\n\n                if (hasher.isUnique(pos)) {\n                    mergedIndices.push(mesh.vertPos.length);\n                    mesh.vertPos.push(pos);\n                } else {\n                    const [x, y, z] = pos;\n                    let k = 0;\n                    for (; k < mesh.vertPos.length; k++) {\n                        const [ox, oy, oz] = mesh.vertPos[k];\n                        if (ox === x && oy === y && oz === z) {\n                            break;\n                        }\n                    }\n\n                    if (k === mesh.vertPos.length) {\n                        mergedIndices.push(mesh.vertPos.length);\n                        mesh.vertPos.push(pos);\n                    } else {\n                        mergedIndices.push(k);\n                    }\n                }\n            }\n\n            // make triangles\n            let tri = 0;\n            if (indexData === null) {\n                for (let i = 0; i < vertexCount;) {\n                    mesh.triVerts[jm++] = [\n                        mergedIndices[i++],\n                        mergedIndices[i++],\n                        mergedIndices[i++]\n                    ];\n\n                    if (submeshMap) {\n                        submeshMap[js++] = submeshIdx;\n                        submeshMap[js++] = tri++;\n                    }\n                }\n            } else {\n                for (let i = 0; i < vertexCount;) {\n                    mesh.triVerts[jm++] = [\n                        mergedIndices[indexData[i++]],\n                        mergedIndices[indexData[i++]],\n                        mergedIndices[indexData[i++]]\n                    ];\n\n                    if (submeshMap) {\n                        submeshMap[js++] = submeshIdx;\n                        submeshMap[js++] = tri++;\n                    }\n                }\n            }\n        }\n\n        if (jm !== mesh.triVerts.length) {\n            throw new Error('Unexpected manifold triangle count');\n        }\n\n        if (submeshMap) {\n            if (js !== submeshMap.length) {\n                throw new Error(`Unexpected iterator position for submeshMap; expected ${submeshMap.length}, got ${js}`);\n            }\n\n            return [submeshMap, mesh];\n        } else {\n            return mesh;\n        }\n    }\n\n    static makeIndexBuffer(size: number): [indexData: Uint8Array, indexType: WL.MeshIndexType] | [indexData: Uint16Array, indexType: WL.MeshIndexType] | [indexData: Uint32Array, indexType: WL.MeshIndexType] {\n        if (size < 256) {\n            return [new Uint8Array(size), WL.MeshIndexType.UnsignedByte];\n        } else if (size < 65536) {\n            return [new Uint16Array(size), WL.MeshIndexType.UnsignedShort];\n        } else if (size < MAX_INDEX_BUFFER_SIZE) {\n            return [new Uint32Array(size), WL.MeshIndexType.UnsignedInt];\n        } else {\n            throw new Error(`Maximum index buffer size exceeded (${MAX_INDEX_BUFFER_SIZE})`);\n        }\n    }\n}", "// XXX modified TriangleHasher from our OctreeCSG-ea project, but reused for\n// vertex positions instead of triangles\nexport default class VertexHasher {\n    buckets = new Map<number, Float32Array[]>;\n\n    private murmur_32_scramble(k: number): number {\n        k *= 0xcc9e2d51;\n        k = (k << 15) | (k >> 17);\n        k *= 0x1b873593;\n        return k & 0xffffffff;\n    }\n\n    private murmur3_32(data: Float32Array, seed: number): number {\n        let h = seed;\n\n        /* Read in groups of 4. */\n        const view = new Uint32Array(data.buffer);\n        for (const key of view) {\n            h ^= this.murmur_32_scramble(key);\n            h = ((h << 13) & 0xffffffff) | (h >> 19);\n            h = (h * 5 + 0xe6546b64) & 0xffffffff;\n        }\n\n        /* Finalize. */\n        h ^= view.byteLength;\n        h ^= h >> 16;\n        h = (h * 0x85ebca6b) & 0xffffffff;\n        h ^= h >> 13;\n        h = (h * 0xc2b2ae35) & 0xffffffff;\n        h ^= h >> 16;\n        return h;\n    }\n\n    private getHash(pos: Float32Array): number {\n        return this.murmur3_32(pos, 0xea8ed414);\n    }\n\n    isUnique(pos: Float32Array) {\n        const hash = this.getHash(pos);\n        const arr = this.buckets.get(hash);\n\n        if (arr) {\n            for (const other of arr) {\n                if (pos[0] === other[0] && pos[1] === other[1] && pos[2] === other[2]) {\n                    return false;\n                }\n            }\n\n            arr.push(pos);\n        } else {\n            this.buckets.set(hash, [pos]);\n        }\n\n        return true;\n    }\n\n    clear() {\n        this.buckets.clear();\n    }\n}", "import { BaseManifoldWLMesh, Submesh, SubmeshMap } from './BaseManifoldWLMesh';\nimport { vec3 } from 'gl-matrix';\n\nimport type { vec2 } from 'gl-matrix';\n\nconst internalCtorKey = Symbol();\ntype InternalCtorArgs = [ctorKey: symbol, width: number, height: number, depth: number, submeshes: Array<Submesh>, premadeManifoldMesh: Mesh, submeshMap: SubmeshMap];\n\nexport type CuboidFaceUVs = [tl: vec2, bl: vec2, br: vec2, tr: vec2];\nexport type CuboidFaceUVPosRatio = number;\n\nexport interface CuboidMaterialOptions {\n    leftMaterial?: WL.Material;\n    rightMaterial?: WL.Material;\n    downMaterial?: WL.Material;\n    upMaterial?: WL.Material;\n    backMaterial?: WL.Material;\n    frontMaterial?: WL.Material;\n}\n\nexport interface CuboidOptions extends CuboidMaterialOptions {\n    leftUVs?: CuboidFaceUVs | CuboidFaceUVPosRatio;\n    rightUVs?: CuboidFaceUVs | CuboidFaceUVPosRatio;\n    downUVs?: CuboidFaceUVs | CuboidFaceUVPosRatio;\n    upUVs?: CuboidFaceUVs | CuboidFaceUVPosRatio;\n    backUVs?: CuboidFaceUVs | CuboidFaceUVPosRatio;\n    frontUVs?: CuboidFaceUVs | CuboidFaceUVPosRatio;\n    center?: boolean;\n}\n\ntype Quad = [tl: number, bl: number, br: number, tr: number];\n\nfunction makeUVs(uSpan: number, vSpan: number): [ tl: vec2, bl: vec2, br: vec2, tr: vec2] {\n    // tl, bl, br, tr\n    return [ [0, vSpan], [0, 0], [uSpan, 0], [uSpan, vSpan] ];\n}\n\nfunction makeMesh(quad: Quad, vertPos: Array<Vec3>, normal: vec3, uvs: CuboidFaceUVs | CuboidFaceUVPosRatio | undefined, uSpan: number, vSpan: number, wlMeshOpts: { vertexCount: number, indexData: Uint8Array, indexType: WL.MeshIndexType }): WL.Mesh {\n    // make mesh\n    const mesh = new WL.Mesh(wlMeshOpts);\n\n    const positions = mesh.attribute(WL.MeshAttribute.Position);\n    if (!positions) {\n        throw new Error('Could not get position MeshAttributeAccessor');\n    }\n\n    const normals = mesh.attribute(WL.MeshAttribute.Normal);\n    const texCoords = mesh.attribute(WL.MeshAttribute.TextureCoordinate);\n\n    // resolve actual uv values\n    let finalUVs: CuboidFaceUVs | undefined = undefined;\n    if (texCoords) {\n        if (uvs) {\n            if (typeof uvs === 'number') {\n                finalUVs = makeUVs(uSpan * uvs, vSpan * uvs);\n            } else {\n                finalUVs = uvs;\n            }\n        } else {\n            finalUVs = makeUVs(uSpan, vSpan);\n        }\n    }\n\n    // populate mesh vertex data\n    positions.set(0, [\n        ...vertPos[quad[0]],\n        ...vertPos[quad[1]],\n        ...vertPos[quad[2]],\n        ...vertPos[quad[3]]\n    ]);\n\n    if (normals) {\n        normals.set(0, normal);\n        normals.set(1, normal);\n        normals.set(2, normal);\n        normals.set(3, normal);\n    }\n\n    if (texCoords) {\n        texCoords.set(0, [\n            ...(finalUVs as CuboidFaceUVs)[0],\n            ...(finalUVs as CuboidFaceUVs)[1],\n            ...(finalUVs as CuboidFaceUVs)[2],\n            ...(finalUVs as CuboidFaceUVs)[3]\n        ]);\n    }\n\n    return mesh;\n}\n\nfunction trisFromQuads(triVerts: Array<Vec3>, quadIndices: Array<Quad>) {\n    // bottom-left tri, then top-right tri\n    // triVerts is assumed to have pre-allocated enough size\n    const quadCount = quadIndices.length;\n    for (let i = 0, j = 0; i < quadCount; i++) {\n        const quad = quadIndices[i];\n        triVerts[j++] = [quad[0], quad[1], quad[2]];\n        triVerts[j++] = [quad[0], quad[2], quad[3]];\n    }\n}\n\nexport class RectangularCuboidMesh extends BaseManifoldWLMesh {\n    public readonly width: number;\n    public readonly height: number;\n    public readonly depth: number;\n\n    constructor(internalCtorArgs: InternalCtorArgs);\n    constructor(width: number, height: number, depth: number, options?: CuboidOptions);\n    constructor(arg0: number | InternalCtorArgs, arg1?: number, arg2?: number, arg3?: CuboidOptions) {\n        if (arguments.length === 1 && Array.isArray(arg0) && arg0.length === 7 && arg0[0] === internalCtorKey) {\n            // internal constructor. not for public use. implemented this way\n            // because typescript doesn't support multiple constructors\n            const internalCtorArgs = arg0 as InternalCtorArgs;\n            super(internalCtorArgs[4], internalCtorArgs[5], internalCtorArgs[6]);\n\n            this.width = internalCtorArgs[1];\n            this.height = internalCtorArgs[2];\n            this.depth = internalCtorArgs[3];\n            return;\n        } else if (arguments.length !== 3 && arguments.length !== 4) {\n            throw new Error('Unexpected number of arguments. Expected 3 or 4 arguments');\n        }\n\n        const width = arg0 as number;\n        const height = arg1 as number;\n        const depth = arg2 as number;\n        const options = arg3 as CuboidOptions | undefined;\n\n        // index array with single face\n        const indexType = WL.MeshIndexType.UnsignedByte;\n        const indexData = new Uint8Array(6);\n        indexData[0] = 0;\n        indexData[1] = 1;\n        indexData[2] = 2;\n        indexData[3] = 0;\n        indexData[4] = 2;\n        indexData[5] = 3;\n\n        // make manifold mesh\n        const center = options?.center ?? true;\n        const left = center ? (-width / 2) : 0;\n        const right = center ? (width / 2) : width;\n        const down = center ? (-height / 2) : 0;\n        const up = center ? (height / 2) : height;\n        const back = center ? (-depth / 2) : 0;\n        const front = center ? (depth / 2) : depth;\n\n        const vertPos: Array<Vec3> = [\n            [ left, down, back ],\n            [ right, down, back ],\n            [ left, up, back ],\n            [ right, up, back ],\n            [ left, down, front ],\n            [ right, down, front ],\n            [ left, up, front ],\n            [ right, up, front ],\n        ];\n\n        // manifold indices for each face in CCW order\n        const faceIndices: Array<Quad> = [\n            [ 2, 0, 4, 6 ], // left face\n            [ 7, 5, 1, 3 ], // right face\n            [ 4, 0, 1, 5 ], // down face\n            [ 2, 6, 7, 3 ], // up face\n            [ 3, 1, 0, 2 ], // back face\n            [ 6, 4, 5, 7 ], // front face\n        ]\n\n        const triVerts = new Array<Vec3>(12);\n        trisFromQuads(triVerts, faceIndices);\n\n        const manifoldMesh = <Mesh>{ triVerts, vertPos };\n\n        // make submeshes\n        const wlMeshOpts = { vertexCount: 4, indexData, indexType };\n        const leftMesh = makeMesh(faceIndices[0], vertPos, [-1, 0, 0], options?.leftUVs, depth, height, wlMeshOpts);\n        const rightMesh = makeMesh(faceIndices[1], vertPos, [1, 0, 0], options?.rightUVs, depth, height, wlMeshOpts);\n        const downMesh = makeMesh(faceIndices[2], vertPos, [0, -1, 0], options?.downUVs, width, depth, wlMeshOpts);\n        const upMesh = makeMesh(faceIndices[3], vertPos, [0, 1, 0], options?.upUVs, width, depth, wlMeshOpts);\n        const backMesh = makeMesh(faceIndices[4], vertPos, [0, 0, -1], options?.backUVs, width, height, wlMeshOpts);\n        const frontMesh = makeMesh(faceIndices[5], vertPos, [0, 0, 1], options?.frontUVs, width, height, wlMeshOpts);\n\n        // make submesh map\n        const submeshMap: SubmeshMap = new Float32Array([\n            0, 0, 0, 1, // left plane\n            1, 0, 1, 1, // right plane\n            2, 0, 2, 1, // down plane\n            3, 0, 3, 1, // up plane\n            4, 0, 4, 1, // back plane\n            5, 0, 5, 1, // front plane\n        ]);\n\n        super([\n            [ leftMesh, options?.leftMaterial ?? null ],\n            [ rightMesh, options?.rightMaterial ?? null ],\n            [ downMesh, options?.downMaterial ?? null ],\n            [ upMesh, options?.upMaterial ?? null ],\n            [ backMesh, options?.backMaterial ?? null ],\n            [ frontMesh, options?.frontMaterial ?? null ],\n        ], manifoldMesh, submeshMap);\n\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n    }\n\n    clone(materials?: CuboidMaterialOptions): RectangularCuboidMesh {\n        return new RectangularCuboidMesh(<InternalCtorArgs>[\n            internalCtorKey,\n            this.width,\n            this.height,\n            this.depth,\n            [\n                [ this.submeshes[0][0], materials?.leftMaterial ?? null ],\n                [ this.submeshes[1][0], materials?.rightMaterial ?? null ],\n                [ this.submeshes[2][0], materials?.downMaterial ?? null ],\n                [ this.submeshes[3][0], materials?.upMaterial ?? null ],\n                [ this.submeshes[4][0], materials?.backMaterial ?? null ],\n                [ this.submeshes[5][0], materials?.frontMaterial ?? null ],\n            ],\n            this.premadeManifoldMesh,\n            this.submeshMap\n        ]);\n    }\n}", "import { CuboidMaterialOptions, RectangularCuboidMesh } from './RectangularCuboidMesh';\n\nexport class CubeMesh extends RectangularCuboidMesh {\n    constructor(length: number, options?: CuboidMaterialOptions) {\n        super(length, length, length, options);\n    }\n}", "// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path=\"../../types/globals.d.ts\" />\n\nimport { mat3, mat4, vec2, vec3 } from 'gl-matrix';\nimport { BaseManifoldWLMesh, Submesh, SubmeshMap } from './BaseManifoldWLMesh';\nimport triangulate2DPolygon from './triangulation/triangulate-2d-polygon';\nimport type { CurveFrame, CurveFrames } from './rmf/curve-frame';\n\nconst internalCtorKey = Symbol();\ntype InternalCtorArgs = [ctorKey: symbol, submeshes: Array<Submesh>, premadeManifoldMesh: Mesh, submeshMap: SubmeshMap];\n\nconst temp0 = vec3.create();\n\ntype SegmentsUVs = [startV: number, endV: number, segmentsUs: Array<number>];\n\nexport interface ExtrusionMaterialOptions {\n    startMaterial?: WL.Material;\n    endMaterial?: WL.Material;\n    segmentMaterial?: WL.Material;\n}\n\nexport interface ExtrusionOptions extends ExtrusionMaterialOptions {\n    smoothNormals?: boolean;\n    startBaseUVs?: Array<vec2>;\n    endBaseUVs?: Array<vec2>;\n    segmentsUVs?: [startV: number | null, endV: number | null, segmentsUs: Array<number> | null];\n}\n\nfunction getMatrix(outputMat: mat4, frame: CurveFrame, position: vec3) {\n    // r (normal) = +y, s (binormal) = +x, t (tangent) = +z\n    // make matrix from position and frame\n    const [r, s, t] = frame;\n    mat4.set(\n        outputMat,\n        s[0], s[1], s[2], 0,\n        r[0], r[1], r[2], 0,\n        t[0], t[1], t[2], 0,\n        position[0], position[1], position[2], 1\n    );\n}\n\nexport class ExtrusionMesh extends BaseManifoldWLMesh {\n    constructor(internalCtorArgs: InternalCtorArgs);\n    constructor(polyline: Array<vec2>, curvePositions: Array<vec3>, curveFrames: CurveFrames, options?: ExtrusionOptions);\n    constructor(arg0: Array<vec2> | InternalCtorArgs, arg1?: Array<vec3>, arg2?: CurveFrames, arg3?: ExtrusionOptions) {\n        if (arguments.length === 1 && Array.isArray(arg0) && arg0.length === 4 && arg0[0] === internalCtorKey) {\n            // internal constructor. not for public use. implemented this way\n            // because typescript doesn't support multiple constructors\n            const internalCtorArgs = arg0 as InternalCtorArgs;\n            super(internalCtorArgs[1], internalCtorArgs[2], internalCtorArgs[3]);\n            return;\n        } else if (arguments.length !== 3 && arguments.length !== 4) {\n            throw new Error('Unexpected number of arguments. Expected 3 or 4 arguments');\n        }\n\n        const polyline = arg0 as Array<vec2>;\n        const curvePositions = arg1 as Array<vec3>;\n        const curveFrames = arg2 as CurveFrames;\n        const options = arg3 as ExtrusionOptions;\n\n        // validate curve\n        const pointCount = curvePositions.length;\n        const loopLen = polyline.length;\n\n        if (curveFrames.length !== pointCount) {\n            throw new Error('There must be at least one frame per point');\n        }\n\n        if (pointCount < 2) {\n            throw new Error('There must be at least 1 segment (2 points) in the curve');\n        }\n\n        if (loopLen < 3) {\n            throw new Error('There must be at least 3 points in the polyline');\n        }\n\n        // validate base UVs\n        const startBaseUVs: Array<vec2> | null = options?.startBaseUVs ?? null;\n        if (startBaseUVs && startBaseUVs.length !== loopLen) {\n            throw new Error('Start base UV count must match polyline length');\n        }\n\n        const endBaseUVs: Array<vec2> | null = options?.endBaseUVs ?? null;\n        if (endBaseUVs && endBaseUVs.length !== loopLen) {\n            throw new Error('End base UV count must match polyline length');\n        }\n\n        // validate segment UVs\n        let needsExtraPoint = false;\n        let segmentsUVs: SegmentsUVs | null = null;\n        const inputSegmentsUVs = options?.segmentsUVs;\n        if (inputSegmentsUVs) {\n            let inputSegmentsUs = inputSegmentsUVs[2];\n\n            if (inputSegmentsUs) {\n                if (inputSegmentsUs.length !== loopLen && inputSegmentsUs.length !== loopLen + 1) {\n                    throw new Error('Segments U count must match polyline length, or have 1 more for the wrap-around value');\n                }\n            } else {\n                inputSegmentsUs = new Array(loopLen + 1);\n                for (let i = 0; i <= loopLen; i++) {\n                    inputSegmentsUs[i] = i / loopLen;\n                }\n            }\n\n            needsExtraPoint = inputSegmentsUs.length === (loopLen + 1);\n\n            segmentsUVs = [\n                inputSegmentsUVs[0] ?? 0,\n                inputSegmentsUVs[1] ?? 1,\n                inputSegmentsUs,\n            ];\n        }\n\n        // triangulate base\n        const triangulatedBase = triangulate2DPolygon(polyline);\n        const triangulatedBaseLen = triangulatedBase.length;\n\n        // calculate vertex count and prepare index data (wle and manifold)\n        const hasSmoothNormals = options?.smoothNormals ?? false;\n        const manifVertexCount = loopLen * pointCount;\n        let segVertexCount = manifVertexCount;\n\n        if (hasSmoothNormals) {\n            segVertexCount += pointCount;\n        } else {\n            segVertexCount *= 2;\n        }\n\n        const segmentCount = pointCount - 1;\n        const baseTriCount = triangulatedBaseLen / 3;\n        const segmentsTriCount = segmentCount * loopLen * 2;\n        const manifTriCount = 2 * baseTriCount + segmentsTriCount;\n\n        const [indexDataStart, indexTypeStart] = BaseManifoldWLMesh.makeIndexBuffer(triangulatedBaseLen);\n        const [indexDataEnd, indexTypeEnd] = BaseManifoldWLMesh.makeIndexBuffer(triangulatedBaseLen);\n        const [indexDataSeg, indexTypeSeg] = BaseManifoldWLMesh.makeIndexBuffer(loopLen * segmentCount * 6);\n\n        // manifold mesh output\n        const manifTriVerts = new Array<Vec3>(manifTriCount);\n        const manifVertPos = new Array<Vec3>(manifVertexCount);\n\n        // populate indexData\n        // vertex data is not yet populated, but the order will be:\n        // - start base polyline vertices\n        // - segment 1 vertices (2x if hasSmoothNormals is false, +1 if needsExtraPoint and hasSmoothNormals are true)\n        // - ...\n        // - segment [segmentCount] vertices (2x if hasSmoothNormals is false, +1 if needsExtraPoint and hasSmoothNormals are true)\n        // - end base polyline vertices\n\n        // the equivalent vertex data for manifold will be:\n        // - segment 1 vertices (always as if hasSmoothNormals is true)\n        // - ...\n        // - segment [segmentCount] vertices (always as if hasSmoothNormals is true)\n\n        // starting base indices\n        // (wle)\n        indexDataStart.set(triangulatedBase);\n        // (manifold)\n        let manifTri = 0;\n        const lLast = loopLen - 1;\n        for (let i = 0; i < triangulatedBaseLen;) {\n            // XXX manifold reuses segment positions, so the indices need to be\n            // corrected to take the winding order of the polyline into account\n            manifTriVerts[manifTri++] = [\n                lLast - triangulatedBase[i++],\n                lLast - triangulatedBase[i++],\n                lLast - triangulatedBase[i++],\n            ];\n        }\n\n        // segment indices\n        let segmentStride = loopLen;\n        if (!hasSmoothNormals) {\n            segmentStride *= 2;\n        }\n\n        let segmentStrideExtra = segmentStride;\n        if (hasSmoothNormals && needsExtraPoint) {\n            segmentStrideExtra++;\n        }\n\n        let segmentStart = 0;\n        let segmentEnd = segmentStrideExtra;\n        let manifSegmentStart = 0;\n        let manifSegmentEnd = loopLen;\n\n        let i = 0;\n        for (let s = 0; s < segmentCount; s++) {\n            // (wle)\n            if (hasSmoothNormals) {\n                for (let l = 0; l < segmentStride; l++) {\n                    const blIdx = segmentStart + l;\n                    const trIdx = segmentEnd + (l + 1) % segmentStrideExtra;\n\n                    // bottom-right triangle\n                    indexDataSeg[i++] = blIdx;\n                    indexDataSeg[i++] = segmentStart + (l + 1) % segmentStrideExtra;\n                    indexDataSeg[i++] = trIdx;\n\n                    // top-left triangle\n                    indexDataSeg[i++] = blIdx;\n                    indexDataSeg[i++] = trIdx;\n                    indexDataSeg[i++] = segmentEnd + l;\n                }\n            } else {\n                for (let l = 0; l < segmentStride; l += 2) {\n                    const blIdx = segmentStart + l;\n                    const tlIdx = segmentEnd + l;\n                    const trIdx = tlIdx + 1;\n\n                    // bottom-right triangle\n                    indexDataSeg[i++] = blIdx;\n                    indexDataSeg[i++] = blIdx + 1;\n                    indexDataSeg[i++] = trIdx;\n\n                    // top-left triangle\n                    indexDataSeg[i++] = blIdx;\n                    indexDataSeg[i++] = trIdx;\n                    indexDataSeg[i++] = tlIdx;\n                }\n            }\n\n            segmentStart += segmentStrideExtra;\n            segmentEnd += segmentStrideExtra;\n\n            // (manifold)\n            for (let l = 0; l < loopLen; l++) {\n                const blIdx = manifSegmentStart + l;\n                const trIdx = manifSegmentEnd + (l + 1) % loopLen;\n\n                // bottom-right triangle\n                manifTriVerts[manifTri++] = [\n                    blIdx,\n                    manifSegmentStart + (l + 1) % loopLen,\n                    trIdx,\n                ];\n\n                // top-left triangle\n                manifTriVerts[manifTri++] = [\n                    blIdx,\n                    trIdx,\n                    manifSegmentEnd + l,\n                ];\n            }\n\n            manifSegmentStart += loopLen;\n            manifSegmentEnd += loopLen;\n        }\n\n        // ending base indices\n        for (let j = 0, endWLEIdx = 0; j < triangulatedBaseLen;) {\n            // XXX winding order needs to be flipped since the end base is in\n            // the opposite direction (ish) of the start base\n            const c = triangulatedBase[j++];\n            const b = triangulatedBase[j++];\n            const a = triangulatedBase[j++];\n\n            // (wle)\n            indexDataEnd[endWLEIdx++] = a;\n            indexDataEnd[endWLEIdx++] = b;\n            indexDataEnd[endWLEIdx++] = c;\n\n            // XXX manifold reuses segment positions, so the indices need to be\n            // corrected to take the winding order of the polyline into account\n            manifTriVerts[manifTri++] = [\n                lLast - a + manifSegmentStart,\n                lLast - b + manifSegmentStart,\n                lLast - c + manifSegmentStart,\n            ];\n        }\n\n        // construct parent class\n        const startMesh = new WL.Mesh({ vertexCount: loopLen, indexData: indexDataStart, indexType: indexTypeStart });\n        const segMesh = new WL.Mesh({ vertexCount: segVertexCount, indexData: indexDataSeg, indexType: indexTypeSeg });\n        const endMesh = new WL.Mesh({ vertexCount: loopLen, indexData: indexDataEnd, indexType: indexTypeEnd });\n\n        super([\n            [ startMesh, options?.startMaterial ?? null ], // start base\n            [ segMesh, options?.segmentMaterial ?? null ], // segments\n            [ endMesh, options?.endMaterial ?? null ], // end base\n        ], <Mesh>{\n            triVerts: manifTriVerts,\n            vertPos: manifVertPos,\n        });\n\n        // get mesh accessors\n        // (start base)\n        const baseBufLen = loopLen * 3;\n        const startPositions = startMesh.attribute(WL.MeshAttribute.Position);\n        if (!startPositions) {\n            throw new Error('Could not get position mesh attribute accessor (start base mesh)');\n        }\n        const startPosBuf = new Float32Array(baseBufLen);\n\n        const startNormals = startMesh.attribute(WL.MeshAttribute.Normal);\n        let startNormBuf: Float32Array | null = null;\n        if (startNormals) {\n            startNormBuf = new Float32Array(baseBufLen);\n        }\n\n        const baseTexCoordBufLen = loopLen * 2;\n        let startTexCoords: WL.MeshAttributeAccessor | null;\n        let startTexCoordBuf: Float32Array | null = null;\n        if (startBaseUVs) {\n            startTexCoords = startMesh.attribute(WL.MeshAttribute.TextureCoordinate);\n            if (startTexCoords) {\n                startTexCoordBuf = new Float32Array(baseTexCoordBufLen);\n            } else {\n                console.warn('Start base UVs ignored; texture coordinate mesh attribute not available');\n            }\n        }\n\n        // (segments)\n        const segBufLen = pointCount * segmentStrideExtra * 3;\n        const segPositions = segMesh.attribute(WL.MeshAttribute.Position);\n        if (!segPositions) {\n            throw new Error('Could not get position mesh attribute accessor (end base mesh)');\n        }\n        const segPosBuf = new Float32Array(segBufLen);\n\n        const segNormals = segMesh.attribute(WL.MeshAttribute.Normal);\n        let segNormBuf: Float32Array | null = null;\n        if (segNormals) {\n            segNormBuf = new Float32Array(segBufLen);\n        }\n\n        let segTexCoords: WL.MeshAttributeAccessor | null;\n        let segTexCoordBuf: Float32Array | null = null;\n        if (segmentsUVs) {\n            segTexCoords = segMesh.attribute(WL.MeshAttribute.TextureCoordinate);\n            if (segTexCoords) {\n                segTexCoordBuf = new Float32Array(pointCount * segmentStrideExtra * 2);\n            } else {\n                console.warn('End base UVs ignored; texture coordinate mesh attribute not available');\n            }\n        }\n\n        // (end base)\n        const endPositions = endMesh.attribute(WL.MeshAttribute.Position);\n        if (!endPositions) {\n            throw new Error('Could not get position mesh attribute accessor (end base mesh)');\n        }\n        const endPosBuf = new Float32Array(baseBufLen);\n\n        const endNormals = endMesh.attribute(WL.MeshAttribute.Normal);\n        let endNormBuf: Float32Array | null = null;\n        if (endNormals) {\n            endNormBuf = new Float32Array(baseBufLen);\n        }\n\n        let endTexCoords: WL.MeshAttributeAccessor | null;\n        let endTexCoordBuf: Float32Array | null = null;\n        if (endBaseUVs) {\n            endTexCoords = endMesh.attribute(WL.MeshAttribute.TextureCoordinate);\n            if (endTexCoords) {\n                endTexCoordBuf = new Float32Array(baseTexCoordBufLen);\n            } else {\n                console.warn('End base UVs ignored; texture coordinate mesh attribute not available');\n            }\n        }\n\n        const hasVertexNormals = startNormBuf || endNormBuf || segNormBuf;\n\n        // make submesh map\n        // 0: startMesh\n        // 1: segMesh\n        // 2: endMesh\n        const submeshMap: SubmeshMap = new Float32Array(manifTriCount * 2);\n\n        i = 0;\n        const jEndOffset = (baseTriCount + segmentsTriCount) * 2;\n        for (let j = 0; i < triangulatedBaseLen; i++) {\n            // start and end bases submesh indices\n            submeshMap[j] = 0\n            submeshMap[jEndOffset + j++] = 2;\n            // start and end bases triangle indices\n            submeshMap[j] = i;\n            submeshMap[jEndOffset + j++] = i;\n        }\n\n        i = 0;\n        for (let j = baseTriCount * 2; i < segmentsTriCount; i++) {\n            // segment triangle indices\n            submeshMap[j++] = 1;\n            submeshMap[j++] = i;\n        }\n\n        this.submeshMap = submeshMap;\n\n        // pre-calculate untransformed normals of each edge in the polyline, and\n        // smooth normals for each vertex, if smooth normals are enabled\n        let edgeNormals: Array<vec3> | null = null;\n        let smoothNormals: Array<vec3> | null = null;\n\n        if (hasVertexNormals) {\n            edgeNormals = new Array(loopLen);\n\n            if (hasSmoothNormals) {\n                smoothNormals = new Array(loopLen);\n            }\n\n            // first edge normal\n            vec3.set(temp0, 0, 0, -1);\n            const lXYLast = polyline[0];\n            const mXYLast = polyline[lLast];\n            const lastEdgeNormal = vec3.fromValues(lXYLast[0] - mXYLast[0], lXYLast[1] - mXYLast[1], 0);\n            edgeNormals[lLast] = vec3.cross(lastEdgeNormal, temp0, lastEdgeNormal);\n\n            // other edge normals + smooth normals\n            for (let l = 0; l < lLast; l++) {\n                const m = l + 1;\n                const lXY = polyline[lLast - l];\n                const mXY = polyline[lLast - m];\n                const edgeNormal = vec3.fromValues(lXY[0] - mXY[0], lXY[1] - mXY[1], 0);\n                edgeNormals[l] = vec3.cross(edgeNormal, temp0, edgeNormal);\n\n                if (smoothNormals) {\n                    const lastEdge = l === 0 ? lLast : (l - 1);\n                    const prevEdgeNormal = edgeNormals[lastEdge];\n                    const smoothNormal = vec3.add(vec3.create(), prevEdgeNormal, edgeNormal);\n                    vec3.normalize(smoothNormal, smoothNormal);\n                    smoothNormals[l] = smoothNormal;\n                }\n            }\n\n            // last smooth vertex normal\n            if (smoothNormals) {\n                const lastSmoothNormal = vec3.add(vec3.create(), edgeNormals[lLast - 1], edgeNormals[lLast]);\n                vec3.normalize(lastSmoothNormal, lastSmoothNormal);\n                smoothNormals[lLast] = lastSmoothNormal;\n            }\n        }\n\n        // pre-calculate segment positions. vertex positions for manifold are\n        // populated this way. also pre-calculate extrusion length\n        const matrix = mat4.create();\n        let extrusionLength = 0;\n\n        i = 0;\n        for (let p = 0; p < pointCount; p++) {\n            getMatrix(matrix, curveFrames[p], curvePositions[p]);\n\n            if (p > 0) {\n                extrusionLength += vec3.distance(curvePositions[p], curvePositions[p - 1]);\n            }\n\n            for (let l = 0; l < loopLen; l++) {\n                const xy = polyline[lLast - l];\n                const pos = vec3.fromValues(xy[0], xy[1], 0) as Vec3;\n                vec3.transformMat4(pos, pos, matrix);\n                manifVertPos[i++] = pos;\n            }\n        }\n\n        // make start base vertices\n        getMatrix(matrix, curveFrames[0], curvePositions[0]);\n        const startNormal = vec3.clone(curveFrames[0][2]); // [2] = t = curve tangent\n        vec3.negate(startNormal, startNormal);\n\n        i = 0;\n        let uv = 0;\n        for (let l = 0; l < loopLen; l++) {\n            startPosBuf.set(manifVertPos[lLast - l], i);\n\n            if (startNormBuf) {\n                startNormBuf.set(startNormal, i);\n            }\n            if (startTexCoordBuf) {\n                startTexCoordBuf.set((startBaseUVs as Array<vec2>)[l], uv);\n                uv += 2;\n            }\n\n            i += 3;\n        }\n\n        // make segment vertices\n        const normalMatrix = mat3.create();\n\n        i = 0;\n        let curLength = 0, iTexCoord = 0, vRange = 0;\n\n        if (segmentsUVs) {\n            vRange = segmentsUVs[1] - segmentsUVs[0];\n        }\n\n        for (let p = 0; p < pointCount; p++) {\n            getMatrix(matrix, curveFrames[p], curvePositions[p]);\n            const lOffset = p * loopLen;\n\n            if (p > 0) {\n                curLength += vec3.distance(curvePositions[p], curvePositions[p - 1]);\n            }\n\n            if (segNormBuf) {\n                // XXX don't use normalFromMat4 or you will always get identity matrices\n                mat3.fromMat4(normalMatrix, matrix);\n            }\n\n            for (let l = 0; l < loopLen; l++) {\n                segPosBuf.set(manifVertPos[l + lOffset], i);\n\n                if (smoothNormals) {\n                    if (segNormBuf) {\n                        vec3.transformMat3(temp0, smoothNormals[l], normalMatrix);\n                        segNormBuf.set(temp0, i);\n                    }\n                    if (segTexCoordBuf) {\n                        const u = (segmentsUVs as SegmentsUVs)[2][l];\n                        const v = vRange * curLength / extrusionLength;\n                        segTexCoordBuf.set([u, v], iTexCoord);\n                        iTexCoord += 2;\n                    }\n                } else {\n                    if (segNormBuf) {\n                        vec3.transformMat3(temp0, (edgeNormals as Array<vec3>)[l], normalMatrix);\n                        segNormBuf.set(temp0, i);\n                        segNormBuf.set(temp0, i + 3);\n                    }\n                    if (segTexCoordBuf) {\n                        const u1 = (segmentsUVs as SegmentsUVs)[2][l];\n                        let u2: number;\n\n                        if (needsExtraPoint) {\n                            u2 = (segmentsUVs as SegmentsUVs)[2][l + 1];\n                        } else {\n                            u2 = (segmentsUVs as SegmentsUVs)[2][(l + 1) % loopLen];\n                        }\n\n                        const v = vRange * curLength / extrusionLength;\n                        segTexCoordBuf.set([u1, v, u2, v], iTexCoord);\n                        iTexCoord += 4;\n                    }\n\n                    i += 3;\n\n                    segPosBuf.set(manifVertPos[(l + 1) % loopLen + lOffset], i);\n                }\n\n                i += 3;\n            }\n\n            // add extra point for segment if needed\n            if (smoothNormals && needsExtraPoint) {\n                segPosBuf.set(manifVertPos[lOffset], i);\n\n                if (segNormBuf) {\n                    vec3.transformMat3(temp0, smoothNormals[0], normalMatrix);\n                    segNormBuf.set(temp0, i);\n                }\n                if (segTexCoordBuf) {\n                    const u = (segmentsUVs as SegmentsUVs)[2][loopLen];\n                    const v = vRange * curLength / extrusionLength;\n                    segTexCoordBuf.set([u, v], iTexCoord);\n                    iTexCoord += 2;\n                }\n\n                i += 3;\n            }\n        }\n\n        // make end base vertices\n        getMatrix(matrix, curveFrames[segmentCount], curvePositions[segmentCount]);\n        const endNormal = curveFrames[segmentCount][2]; // [2] = t = curve tangent\n        const lEndOffset = segmentCount * loopLen;\n\n        i = 0, uv = 0;\n        for (let l = 0; l < loopLen; l++) {\n            endPosBuf.set(manifVertPos[lEndOffset + lLast - l], i);\n\n            if (endNormBuf) {\n                endNormBuf.set(endNormal, i);\n            }\n            if (endTexCoordBuf) {\n                endTexCoordBuf.set((endBaseUVs as Array<vec2>)[l], uv);\n                uv += 2;\n            }\n\n            i += 3;\n        }\n\n        // upload vertex attributes\n        // (start base)\n        startPositions.set(0, startPosBuf);\n\n        if (startNormBuf) {\n            (startNormals as WL.MeshAttributeAccessor).set(0, startNormBuf);\n        }\n        if (startTexCoordBuf) {\n            (startTexCoords as WL.MeshAttributeAccessor).set(0, startTexCoordBuf);\n        }\n\n        // (segments)\n        segPositions.set(0, segPosBuf);\n\n        if (segNormBuf) {\n            (segNormals as WL.MeshAttributeAccessor).set(0, segNormBuf);\n        }\n        if (segTexCoordBuf) {\n            (segTexCoords as WL.MeshAttributeAccessor).set(0, segTexCoordBuf);\n        }\n\n        // (end base)\n        endPositions.set(0, endPosBuf);\n\n        if (endNormBuf) {\n            (endNormals as WL.MeshAttributeAccessor).set(0, endNormBuf);\n        }\n        if (endTexCoordBuf) {\n            (endTexCoords as WL.MeshAttributeAccessor).set(0, endTexCoordBuf);\n        }\n    }\n\n    clone(materials?: ExtrusionMaterialOptions): ExtrusionMesh {\n        return new ExtrusionMesh(<InternalCtorArgs>[\n            internalCtorKey,\n            [\n                [ this.submeshes[0][0], materials?.startMaterial ?? null ],\n                [ this.submeshes[1][0], materials?.segmentMaterial ?? null ],\n                [ this.submeshes[2][0], materials?.endMaterial ?? null ]\n            ],\n            this.premadeManifoldMesh,\n            this.submeshMap\n        ]);\n    }\n}", "import type { vec2 } from 'gl-matrix';\n\nexport default function isClockwise2DPolygon(polyline: Array<vec2>): boolean {\n    // sum up all the edges of the polygon to get 2x signed area. if signed area\n    // is positive, then the polygon is clockwise\n    let sum = 0;\n    const vertCount = polyline.length;\n    let last = polyline[vertCount - 1];\n\n    for (const next of polyline) {\n        sum += (next[0] - last[0]) * (next[1] + last[1]);\n        last = next;\n    }\n\n    return sum >= 0;\n}", "import type { vec2 } from 'gl-matrix';\n\nexport default function sort2DIndices(polyline: Array<vec2>): Array<number> {\n    const indices = Array.from({ length: polyline.length }, (_, i) => i);\n    indices.sort((aIdx, bIdx) => {\n        // if a < b, then -1, if a = b, then 0, if a > b, then 1\n        const a: vec2 = polyline[aIdx];\n        const b: vec2 = polyline[bIdx];\n\n        // compare x\n        if (a[0] < b[0]) {\n            return -1;\n        } else if (a[0] > b[0]) {\n            return 1;\n        } else {\n            // x equal. compare y\n            if (a[1] < b[1]) {\n                return -1;\n            } else if (a[1] > b[1]) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n    });\n\n    return indices;\n}", "import { vec2 } from 'gl-matrix';\n\nfunction getPolygonInLoop(indices: Array<number>, start: number, end: number): Array<number> {\n    const indexCount = indices.length;\n    const output: Array<number> = [start];\n\n    for (let i = (indices.indexOf(start) + 1) % indexCount;; i = (i + 1) % indexCount) {\n        const actualIndex = indices[i];\n        output.push(actualIndex);\n\n        if (actualIndex === end) {\n            return output;\n        } else if (actualIndex === start) {\n            throw new Error(`getPolygonInLoop aborted; infinite loop detected due to possibly invalid split diagonal (${start}, ${end})`);\n        }\n    }\n}\n\nfunction splitPolygonTo(polyline: Array<vec2>, indices: Array<number>, diagonals: Array<[number, number]>, output: Array<Array<vec2>>, flip: boolean) {\n    if (diagonals.length > 0) {\n        // split along first diagonal\n        const [start, end] = diagonals[0];\n        const aIndices = getPolygonInLoop(indices, start, end);\n        const bIndices = getPolygonInLoop(indices, end, start);\n\n        // assign other diagonals to one of the partitions\n        const aDiags = new Array<[number, number]>(), bDiags = new Array<[number, number]>();\n        const diagonalCount = diagonals.length;\n        for (let i = 1; i < diagonalCount; i++) {\n            const [oStart, oEnd] = diagonals[i];\n\n            if (aIndices.indexOf(oStart) >= 0 && aIndices.indexOf(oEnd) >= 0) {\n                aDiags.push([oStart, oEnd]);\n            } else if (bIndices.indexOf(oStart) >= 0 && bIndices.indexOf(oEnd) >= 0) {\n                bDiags.push([oStart, oEnd]);\n            } else {\n                throw new Error(`Invalid split diagonal (${oStart}, ${oEnd})`);\n            }\n        }\n\n        // further split\n        splitPolygonTo(polyline, aIndices, aDiags, output, flip);\n        splitPolygonTo(polyline, bIndices, bDiags, output, flip);\n    } else {\n        // no more diagonals, make actual polyline\n        const indexCount = indices.length;\n        const outPolyline = new Array(indexCount);\n\n        if (flip) {\n            for (let i = 0; i < indexCount; i++) {\n                outPolyline[i] = polyline[indices[indexCount - 1 - i]];\n            }\n        } else {\n            for (let i = 0; i < indexCount; i++) {\n                outPolyline[i] = polyline[indices[i]];\n            }\n        }\n\n        output.push(outPolyline);\n    }\n}\n\nexport default function split2DPolygon(polyline: Array<vec2>, diagonals: Array<[number, number]>, output?: Array<Array<vec2>>, flip = false): Array<Array<vec2>> {\n    if (!output) {\n        output = [];\n    }\n\n    splitPolygonTo(polyline, Array.from({ length: polyline.length }, (_, i) => i), diagonals, output, flip);\n    return output;\n}", "import { vec2 } from 'gl-matrix';\nimport isClockwise2DPolygon from './is-clockwise-2d-polygon';\nimport sort2DIndices from './sort-2d-indices';\nimport split2DPolygon from './split-2d-polygon';\n\nconst TAU = Math.PI * 2;\n\nenum VertexType {\n    Start,\n    End,\n    Regular,\n    Split,\n    Merge\n}\n\nfunction isAbove(p: vec2, q: vec2) {\n    return p[0] < q[0] || (p[0] === q[0] && p[1] < q[1]);\n}\n\nfunction interiorAngle(prev: vec2, cur: vec2, next: vec2) {\n    // XXX angles must be negated due to CCW winding order\n    const prevAngle = -Math.atan2(prev[1] - cur[1], prev[0] - cur[0]);\n    const nextAngle = -Math.atan2(next[1] - cur[1], next[0] - cur[0]);\n    // XXX mod used instead of remainder because angles can be negative\n    return (((nextAngle - prevAngle) % TAU) + TAU) % TAU;\n}\n\nfunction getLeftEdge(polyline: Array<vec2>, status: Set<number>, vertexCount: number, vertex: vec2) {\n    let leftEdge = -1;\n    let leftY = -Infinity;\n\n    for (const lineStartIndex of status) {\n        const lineEndIndex = (lineStartIndex + 1) % vertexCount;\n        const lineStart = polyline[lineStartIndex];\n        const lineEnd = polyline[lineEndIndex];\n\n        let lineMin, lineMax;\n        if (lineStart[0] > lineEnd[0]) {\n            lineMin = lineEnd;\n            lineMax = lineStart;\n        } else {\n            lineMax = lineEnd;\n            lineMin = lineStart;\n        }\n\n        if (vertex[0] >= lineMin[0] && vertex[0] <= lineMax[0]) {\n            // y = mx + c; m = dy / dx; c = y - mx\n            const m = (lineMax[1] - lineMin[1]) / (lineMax[0] - lineMin[0]);\n            const c = lineMin[1] - m * lineMin[0];\n            const y = m * vertex[0] + c;\n\n            if (y <= vertex[1] && y >= leftY) {\n                leftY = y;\n                leftEdge = lineStartIndex;\n            }\n        }\n    }\n\n    if (leftEdge === -1) {\n        throw new Error(`No edge to the left of vertex. Status: ${Array.from(status)}`);\n    }\n\n    return leftEdge;\n}\n\nexport default function partition2DPolygon(polyline: Array<vec2>, output?: Array<Array<vec2>>, isClockwiseHint?: boolean) {\n    // using monotone polygon partitioning algorithm from a book:\n    // Computational Geometry: Algorithms and Applications (second edition,\n    // section 3.2), by Mark de Berg, Marc van Krefeld, and Mark Overmars\n\n    // XXX the algorithm assumes that the input polygon is CCW, but sometimes it\n    // isn't because a uses wants to make, for example, an inverted extrusion.\n    // check for this case\n    if (isClockwiseHint === undefined) {\n        isClockwiseHint = isClockwise2DPolygon(polyline);\n    }\n\n    if (isClockwiseHint) {\n        polyline = polyline.slice().reverse();\n    }\n\n    // sort vertices in polyline. since our triangulation algorithm sweeps from\n    // -X to +X, sort by X values and then Y values, instead of Y then X from\n    // the original algorithm\n    const vertexCount = polyline.length;\n    const helpers = new Map<number, number>();\n    // XXX the original algorithm uses a BST for the status container instead of\n    // a set, but performance has been OK with a set. maybe change in the\n    // future?\n    const status = new Set<number>();\n    const types = new Map<number, VertexType>();\n    const diagonals = new Array<[number, number]>();\n\n    for (const index of sort2DIndices(polyline)) {\n        // get vertex type\n        const prevIndex = ((index - 1 % vertexCount) + vertexCount) % vertexCount;\n        const nextIndex = (index + 1) % vertexCount;\n        const prevVertex = polyline[prevIndex];\n        const vertex = polyline[index];\n        const nextVertex = polyline[nextIndex];\n\n        const abovePrev = isAbove(vertex, prevVertex);\n        const aboveNext = isAbove(vertex, nextVertex);\n\n        if (abovePrev && aboveNext) {\n            // this is either a start or split vertex. check internal angle\n            if (interiorAngle(prevVertex, vertex, nextVertex) < Math.PI) {\n                // start vertex\n                types.set(index, VertexType.Start);\n            } else {\n                // split vertex\n                types.set(index, VertexType.Split);\n\n                const leftEdge = getLeftEdge(polyline, status, vertexCount, vertex);\n                diagonals.push([index, helpers.get(leftEdge) as number]);\n                helpers.set(leftEdge, index);\n            }\n\n            // shared logic\n            status.add(index);\n            helpers.set(index, index);\n\n            continue;\n        } else if (!abovePrev && !aboveNext) {\n            // shared logic\n            const prevHelper = helpers.get(prevIndex);\n            if (prevHelper !== undefined && types.get(prevHelper) === VertexType.Merge) {\n                diagonals.push([index, prevHelper]);\n            }\n\n            status.delete(prevIndex);\n\n            // this is either an end or merge vertex. check internal angle\n            if (interiorAngle(prevVertex, vertex, nextVertex) < Math.PI) {\n                // end vertex\n                types.set(index, VertexType.End);\n            } else {\n                // merge vertex\n                types.set(index, VertexType.Merge);\n\n                const leftEdge = getLeftEdge(polyline, status, vertexCount, vertex);\n                const leftHelper = helpers.get(leftEdge);\n                if (leftHelper !== undefined && types.get(leftHelper) === VertexType.Merge) {\n                    diagonals.push([index, leftHelper]);\n                }\n\n                helpers.set(leftEdge, index);\n            }\n\n            continue;\n        }\n\n        // regular vertex\n        types.set(index, VertexType.Regular);\n\n        // check if interior lies to the right of the vertex. on a CCW polygon,\n        // the polygon interior always lies to the left of an edge, meaning that\n        // the interior lies to the right of a vertex when the edge to the next\n        // vertex is below the vertex\n        if (nextVertex[0] > vertex[0]) {\n            // interior to the right\n            const prevHelper = helpers.get(prevIndex);\n            if (prevHelper !== undefined && types.get(prevHelper) === VertexType.Merge) {\n                diagonals.push([index, prevHelper]);\n            }\n\n            status.delete(prevIndex);\n            status.add(index);\n            helpers.set(index, index);\n        } else {\n            // interior not to the right\n            const leftEdge = getLeftEdge(polyline, status, vertexCount, vertex);\n            const leftHelper = helpers.get(leftEdge);\n            if (leftHelper !== undefined && types.get(leftHelper) === VertexType.Merge) {\n                diagonals.push([index, leftHelper]);\n            }\n\n            helpers.set(leftEdge, index);\n        }\n    }\n\n    // get all partitions by finding all loops in the graph made by the original\n    // polyline and diagonals\n    return split2DPolygon(polyline, diagonals, output, isClockwiseHint);\n}", "import { vec2 } from 'gl-matrix';\nimport isClockwise2DPolygon from './is-clockwise-2d-polygon';\nimport isClockwise2DTriangle from './is-clockwise-2d-triangle';\nimport sort2DIndices from './sort-2d-indices';\n\nconst temp0 = vec2.create();\nconst temp1 = vec2.create();\n\nfunction addTriangle(output: Array<number>, index: number, clockwise: boolean, a: number, b: number, c: number, polyline: Array<vec2>): number {\n    output[index++] = a;\n\n    if (isClockwise2DTriangle(polyline[a], polyline[b], polyline[c]) === clockwise) {\n        output[index++] = b;\n        output[index++] = c;\n    } else {\n        output[index++] = c;\n        output[index++] = b;\n    }\n\n    return index;\n}\n\nfunction isInInterval(index: number, start: number, end: number) {\n    if (start > end) {\n        return index >= start || index < end;\n    } else {\n        return index >= start && index < end;\n    }\n}\n\nexport default function triangulateMonotone2DPolygon(polyline: Array<vec2>, output?: Array<number>, index = 0, isClockwiseHint?: boolean): [trianglesIndices: Array<number>, lastIndex: number] {\n    const vertexCount = polyline.length;\n\n    // fast paths (and error conditions):\n    if (vertexCount < 3) {\n        throw new Error(`Expected input polyline with 3 or more vertices, got ${vertexCount}`);\n    }\n\n    const outputSize = index + (vertexCount - 2) * 3;\n    if (output) {\n        if (output.length < outputSize) {\n            output.length = outputSize;\n        }\n    } else {\n        output = new Array(outputSize);\n    }\n\n    if (vertexCount === 3) {\n        // already a triangle, copy it\n        output[index++] = 0;\n        output[index++] = 1;\n        output[index++] = 2;\n\n        return [output, index];\n    }\n\n    // XXX don't do a special case for squares since the square may not be\n    // convex and may result in bad triangles\n\n    // general case: using monotone polygon triangulation algorithm from a book:\n    // Computational Geometry: Algorithms and Applications (second edition,\n    // section 3.3), by Mark de Berg, Marc van Krefeld, and Mark Overmars\n\n    // XXX triangle orientation is very chaotic, so it is properly oriented\n    // when inserting each triangle in the output instead of relying of the\n    // algorithm's scan order\n    if (isClockwiseHint === undefined) {\n        isClockwiseHint = isClockwise2DPolygon(polyline);\n    }\n\n    // sort vertices by XY respectively\n    const indices = sort2DIndices(polyline);\n    // XXX a vertex is in the \"other\"/\"second\" chain when it comes after or is\n    // at the right-most vertex (last in sorted array), and comes before the\n    // left-most vertex (first in sorted array)\n    const secondChainStart = indices[vertexCount - 1];\n    const secondChainEnd = indices[0];\n    let stack = [indices[0], indices[1]];\n\n    for (let i = 2; i < vertexCount - 1; i++) {\n        const thisIndex = indices[i];\n        const stackLen = stack.length;\n        const topIndex = stack[stackLen - 1];\n\n        if (isInInterval(thisIndex, secondChainStart, secondChainEnd) !== isInInterval(topIndex, secondChainStart, secondChainEnd)) {\n            // opposite chains\n            for (let j = 0; j < stackLen - 1; j++) {\n                index = addTriangle(output, index, isClockwiseHint, thisIndex, stack[j], stack[j + 1], polyline);\n            }\n\n            stack = [topIndex, thisIndex];\n        } else {\n            // same chain\n            let lastPoppedVertex = polyline[topIndex];\n            let lastPoppedIndex = topIndex;\n            stack.pop();\n            const lastDelta = vec2.sub(temp1, lastPoppedVertex, polyline[thisIndex]);\n\n            // swap if delta is going in opposite direction\n            if (thisIndex === (lastPoppedIndex + 1) % vertexCount !== isClockwiseHint) {\n                vec2.negate(lastDelta, lastDelta);\n            }\n\n            while (stack.length > 0) {\n                const nextPoppedIndex = stack[stack.length - 1];\n                const nextPoppedVertex = polyline[nextPoppedIndex];\n\n                // check if diagonal from current vertex to popped vertex is\n                // inside polygon. if not, stop popping\n                const delta = vec2.sub(temp0, nextPoppedVertex, lastPoppedVertex);\n                const cross = lastDelta[0] * delta[1] - lastDelta[1] * delta[0];\n\n                if (cross <= 0) {\n                    break;\n                }\n\n                stack.pop();\n                index = addTriangle(output, index, isClockwiseHint, thisIndex, lastPoppedIndex, nextPoppedIndex, polyline);\n                lastPoppedIndex = nextPoppedIndex;\n                lastPoppedVertex = nextPoppedVertex;\n            }\n\n            stack.push(lastPoppedIndex);\n            stack.push(thisIndex);\n        }\n    }\n\n    const lastIndex = indices[vertexCount - 1];\n    const iterLen = stack.length - 1;\n\n    for (let i = 0; i < iterLen; i++) {\n        index = addTriangle(output, index, isClockwiseHint, lastIndex, stack[i], stack[i + 1], polyline);\n    }\n\n    return [output, index];\n}", "import type { vec2 } from 'gl-matrix';\n\nexport default function isClockwise2DTriangle(a: vec2, b: vec2, c: vec2): boolean {\n    // similar to isClockwise2DPolygon, but optimised for 3 points\n    return (\n        (b[0] - a[0]) * (b[1] + a[1]) +\n        (c[0] - b[0]) * (c[1] + b[1]) +\n        (a[0] - c[0]) * (a[1] + c[1])\n    ) >= 0;\n}", "import { vec2 } from 'gl-matrix';\nimport isClockwise2DPolygon from './is-clockwise-2d-polygon';\nimport partition2DPolygon from './partition-2d-polygon';\nimport triangulateMonotone2DPolygon from './triangulate-monotone-2d-polygon';\n\nexport default function triangulate2DPolygon(polyline: Array<vec2>, output?: Array<number>): Array<number> {\n    const isClockwiseHint = isClockwise2DPolygon(polyline);\n    const partitions = partition2DPolygon(polyline, undefined, isClockwiseHint);\n    let outputSize = 0;\n\n    for (const partition of partitions) {\n        outputSize += (partition.length - 2) * 3;\n    }\n\n    if (output) {\n        if (output.length < outputSize) {\n            output.length = outputSize;\n        }\n    } else {\n        output = new Array(outputSize);\n    }\n\n    let index = 0;\n    for (const partition of partitions) {\n        [output, index] = triangulateMonotone2DPolygon(partition, output, index, isClockwiseHint);\n    }\n\n    return output;\n}", "// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path=\"../../types/globals.d.ts\" />\n\nimport { ExtrusionMesh } from './ExtrusionMesh';\n\nimport type { vec2, vec3 } from 'gl-matrix';\nimport type { CurveFrame } from './rmf/curve-frame';\nimport type { ExtrusionOptions } from './ExtrusionMesh';\n\nexport class LinearExtrusionMesh extends ExtrusionMesh {\n    constructor(polyline: Array<vec2>, depth: number, options?: ExtrusionOptions) {\n        const positions: Array<vec3> = [[0, 0, 0], [0, 0, depth]];\n        const forwardFrame: CurveFrame = depth >= 0\n            ? [[0, 1, 0], [-1, 0, 0], [0, 0, 1]]\n            : [[0, 1, 0], [1, 0, 0], [0, 0, -1]];\n        const frames = [forwardFrame, forwardFrame];\n\n        super(polyline, positions, frames, options);\n    }\n}", "import type { CSGFinalOperation } from './CSGFinalOperation';\nimport { CSGGeometricOperation } from './CSGGeometricOperation';\nimport type { CSGOperation } from './CSGOperation';\nimport type { CSGPrimitive } from './CSGPrimitive';\nimport type { CSGTree } from './CSGTree';\n\nexport type OpTreeCtx<MeshType> = { [key: string | number]: (CSGTree<MeshType> | MeshType) };\n\nfunction iterateOpTreeNode<MeshType>(context: OpTreeCtx<MeshType>, key: string | number, node: CSGTree<MeshType> | MeshType, handleMesh: ((context: OpTreeCtx<MeshType>, key: string | number, mesh: MeshType) => void) | null = null, handlePrimitive: ((context: OpTreeCtx<MeshType>, key: string | number, operation: CSGPrimitive) => void) | null = null, handleOperation: ((context: OpTreeCtx<MeshType>, key: string | number, operation: CSGGeometricOperation<MeshType>) => void) | null = null): void {\n    if ('primitive' in node) {\n        // primitive\n        switch (node.primitive) {\n            case 'cube':\n            case 'cylinder':\n            case 'sphere':\n            case 'tetrahedron':\n                if (handlePrimitive) {\n                    handlePrimitive(context, key, node);\n                }\n                break;\n            default: {\n                // XXX we're kinda fighting the type system here, but oh well\n                const prim = (node as {primitive: string}).primitive;\n                throw new Error(`Unknown primitive: ${prim}`);\n            }\n        }\n    } else if ('operation' in node) {\n        // operation\n        switch (node.operation) {\n            case 'add':\n            case 'union':\n            case 'subtract':\n            case 'difference':\n            case 'intersect':\n            case 'intersection': {\n                // XXX children are iterated from right to left so that they can\n                // be pushed to a stack and then popped at the right order\n                if ('manifolds' in node) {\n                    for (let i = node.manifolds.length - 1; i >= 0; i--) {\n                        iterateOpTreeNode(node.manifolds as unknown as OpTreeCtx<MeshType>, i, node.manifolds[i], handleMesh, handlePrimitive, handleOperation);\n                    }\n                } else {\n                    iterateOpTreeNode(node as unknown as OpTreeCtx<MeshType>, 'right', node.right, handleMesh, handlePrimitive, handleOperation);\n                    iterateOpTreeNode(node as unknown as OpTreeCtx<MeshType>, 'left', node.left, handleMesh, handlePrimitive, handleOperation);\n                }\n\n                if (handleOperation) {\n                    handleOperation(context, key, node);\n                }\n                break;\n            }\n            case 'translate':\n            case 'rotate':\n            case 'scale':\n            case 'transform':\n            case 'refine':\n            case 'asOriginal':\n                iterateOpTreeNode(node as unknown as OpTreeCtx<MeshType>, 'manifold', node.manifold, handleMesh, handlePrimitive, handleOperation);\n                // XXX intentional fallthrough\n            case 'extrude':\n            case 'revolve':\n                if (handleOperation) {\n                    handleOperation(context, key, node);\n                }\n                break;\n            default: {\n                // XXX fighting the type system again...\n                const op = (node as {operation: string}).operation;\n                if (op === 'compose' || op === 'decompose') {\n                    throw new Error(`${op} operation is not implemented yet`);\n                } else {\n                    throw new Error(`Unknown operation: ${op}`);\n                }\n            }\n        }\n    } else {\n        // assume this is a mesh object\n        if (handleMesh) {\n            handleMesh(context, key, node);\n        }\n    }\n}\n\nexport function iterateOpTree<MeshType>(tree: CSGOperation<MeshType>, handleMesh: ((context: OpTreeCtx<MeshType>, key: string | number, mesh: MeshType) => void) | null = null, handlePrimitive: ((context: OpTreeCtx<MeshType>, key: string | number, operation: CSGPrimitive) => void) | null = null, handleOperation: ((context: OpTreeCtx<MeshType>, key: string | number, operation: CSGGeometricOperation<MeshType>) => void) | null = null, handleTopOperation: ((context: OpTreeCtx<MeshType>, key: string | number, topOperation: CSGFinalOperation<MeshType>) => void) | null = null): void {\n    const context = <OpTreeCtx<MeshType>>{\n        root: tree\n    };\n\n    if ('primitive' in tree) {\n        if (handlePrimitive) {\n            handlePrimitive(context, 'root', tree);\n        }\n    } else {\n        switch (tree.operation) {\n            case 'isEmpty':\n            case 'numVert':\n            case 'numTri':\n            case 'numEdge':\n            case 'boundingBox':\n            case 'precision':\n            case 'genus':\n            case 'getProperties':\n            case 'getCurvature':\n            case 'originalID':\n                iterateOpTreeNode(tree as unknown as OpTreeCtx<MeshType>, 'manifold', tree.manifold, handleMesh, handlePrimitive, handleOperation);\n\n                if (handleTopOperation) {\n                    handleTopOperation(context, 'root', tree);\n                }\n                break;\n            default:\n                iterateOpTreeNode(context, 'root', tree, handleMesh, handlePrimitive, handleOperation);\n        }\n    }\n}", "// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path=\"../../types/globals.d.ts\" />\n\nimport { CSGOperation } from '../common/CSGOperation';\nimport { iterateOpTree } from '../common/iterate-operation-tree';\nimport { WorkerResponse } from '../common/WorkerResponse';\nimport { vec3 } from 'gl-matrix';\nimport { BaseManifoldWLMesh } from './BaseManifoldWLMesh';\n\nimport type { WorkerRequest } from '../common/WorkerRequest';\n\ntype MeshArr = Array<[mesh: WL.Mesh, material: WL.Material | null]>;\ntype WorkerTuple = [worker: Worker, jobCount: number];\ntype WorkerArray = Array<WorkerTuple>;\ntype JobResult = MeshArr | boolean | number | Box | Properties | Curvature;\n\nfunction getFromBary(vecSize: number, a: number, b: number, c: number, aBary: Vec3, bBary: Vec3, cBary: Vec3, origAccessor: WL.MeshAttributeAccessor) {\n    const aOrigVal = origAccessor.get(a);\n    const bOrigVal = origAccessor.get(b);\n    const cOrigVal = origAccessor.get(c);\n    const aVec = new Array(vecSize);\n    const cVec = new Array(vecSize);\n    const bVec = new Array(vecSize);\n\n    for (let i = 0; i < vecSize; i++) {\n        aVec[i] = aOrigVal[i] * aBary[0] + bOrigVal[i] * aBary[1] + cOrigVal[i] * aBary[2];\n        bVec[i] = aOrigVal[i] * bBary[0] + bOrigVal[i] * bBary[1] + cOrigVal[i] * bBary[2];\n        cVec[i] = aOrigVal[i] * cBary[0] + bOrigVal[i] * cBary[1] + cOrigVal[i] * cBary[2];\n    }\n\n    return [aVec, bVec, cVec];\n}\n\nfunction setFromBary(i: number, vecSize: number, a: number, b: number, c: number, aBary: Vec3, bBary: Vec3, cBary: Vec3, origAccessor: WL.MeshAttributeAccessor, buffer: Float32Array) {\n    const [aVec, bVec, cVec] = getFromBary(vecSize, a, b, c, aBary, bBary, cBary, origAccessor);\n    buffer.set(aVec, i);\n    i += vecSize;\n    buffer.set(bVec, i);\n    i += vecSize;\n    buffer.set(cVec, i);\n}\n\nexport class ManifoldPool {\n    private wantedWorkerCount: number;\n    private workerPath: string;\n    private libraryPath: string;\n    private workers: WorkerArray | null = null;\n    private nextJobID = 0;\n    private jobs = new Map<number, [resolve: (value: JobResult) => void, reject: (reason: unknown) => void, origMeshes: Array<BaseManifoldWLMesh | WL.Mesh>]>();\n\n    constructor(workerCount: number | null = null, workerPath = 'manifold-wle.worker.min.js', libraryPath = 'manifold.js') {\n        this.wantedWorkerCount = Math.max(\n            1, workerCount ?? Math.ceil(navigator.hardwareConcurrency / 2)\n        );\n        this.workerPath = workerPath;\n        this.libraryPath = libraryPath;\n    }\n\n    private toManifoldMesh(wleMesh: BaseManifoldWLMesh | WL.Mesh): Mesh {\n        if (wleMesh instanceof BaseManifoldWLMesh) {\n            return wleMesh.manifoldMesh;\n        } else if(wleMesh instanceof WL.Mesh) {\n            return BaseManifoldWLMesh.manifoldFromWLE(wleMesh, false);\n        } else {\n            return wleMesh;\n        }\n    }\n\n    private meshToWLEArr(mesh: Mesh, meshRelation: MeshRelation, meshIDMap: Map<number, BaseManifoldWLMesh | WL.Mesh>): MeshArr {\n        // validate triangle count\n        const triCount = mesh.triVerts.length;\n\n        if (triCount === 0) {\n            return [];\n        }\n\n        // map triangles to materials\n        const vertexArrays = new Map<WL.Material | null, Map<WL.Mesh | null, Array<[triIdx: number, origTriIdx: number]>>>();\n        let iTri = 0;\n        for (; iTri < triCount; iTri++) {\n            // get original triangle\n            const triBary = meshRelation.triBary[iTri];\n            const origMesh = meshIDMap.get(triBary.originalID);\n            let wleMesh: WL.Mesh | null;\n            let material: WL.Material;\n            let iTriOrig = iTri;\n\n            if (origMesh instanceof BaseManifoldWLMesh) {\n                [[wleMesh, material], iTriOrig] = origMesh.getTriBarySubmesh(triBary.tri);\n            } else {\n                material = null;\n                wleMesh = origMesh;\n            }\n\n            // get vertex array map (wle mesh -> va)\n            let vaMap = vertexArrays.get(material);\n            if (!vaMap) {\n                vaMap = new Map();\n                vertexArrays.set(material, vaMap);\n            }\n\n            // get vertex array\n            let va = vaMap.get(wleMesh);\n            if (!va) {\n                va = [];\n                vaMap.set(wleMesh, va);\n            }\n\n            // add triangle points to vertex array\n            va.push([iTri, iTriOrig]);\n        }\n\n        // make mesh for each vertex array\n        const meshArr: MeshArr = [];\n\n        for (const [material, vaMap] of vertexArrays) {\n            // count triangles in vertex array\n            let vaTotalTriCount = 0;\n            for (const va of vaMap.values()) {\n                vaTotalTriCount += va.length;\n            }\n\n            // make index buffer\n            const vertexCount = vaTotalTriCount * 3;\n            const [indexData, indexType] = BaseManifoldWLMesh.makeIndexBuffer(vertexCount);\n\n            for (let i = 0; i < vertexCount; i++) {\n                indexData[i] = i;\n            }\n\n            // make mesh from index buffer\n            const wleMesh = new WL.Mesh({ vertexCount, indexType, indexData });\n            const positions = wleMesh.attribute(WL.MeshAttribute.Position);\n\n            const tangents = wleMesh.attribute(WL.MeshAttribute.Tangent);\n            const normals = wleMesh.attribute(WL.MeshAttribute.Normal);\n            const texCoords = wleMesh.attribute(WL.MeshAttribute.TextureCoordinate);\n            const colors = wleMesh.attribute(WL.MeshAttribute.Color);\n            // TODO joint support?\n            const hasExtra: boolean = (tangents || normals || texCoords || colors);\n\n            const positionBuffer = new Float32Array(vertexCount * 3);\n\n            let tangentBuffer: Float32Array | undefined;\n            if (tangents) {\n                tangentBuffer = new Float32Array(vertexCount * 4);\n            }\n\n            let normalBuffer: Float32Array | undefined;\n            if (normals) {\n                normalBuffer = new Float32Array(vertexCount * 3);\n            }\n\n            let texCoordBuffer: Float32Array | undefined;\n            if (texCoords) {\n                texCoordBuffer = new Float32Array(vertexCount * 2);\n            }\n\n            let colorBuffer: Float32Array | undefined;\n            if (colors) {\n                colorBuffer = new Float32Array(vertexCount * 4);\n            }\n\n            let j2 = 0, j3 = 0, j4 = 0;\n            for (const [origMesh, va] of vaMap) {\n                const vaTriCount = va.length;\n\n                for (let i = 0; i < vaTriCount; i++, j2 += 6, j3 += 9, j4 += 12) {\n                    const [triIdx, origTriIdx] = va[i];\n                    const triIndices = mesh.triVerts[triIdx];\n                    const triBary = meshRelation.triBary[triIdx];\n\n                    const aPosNew = mesh.vertPos[triIndices[0]];\n                    const bPosNew = mesh.vertPos[triIndices[1]];\n                    const cPosNew = mesh.vertPos[triIndices[2]];\n\n                    if (hasExtra && origMesh) {\n                        const aBaryIdx = triBary.vertBary[0];\n                        const bBaryIdx = triBary.vertBary[1];\n                        const cBaryIdx = triBary.vertBary[2];\n\n                        let aBary: Vec3;\n                        if (aBaryIdx < 0) {\n                            aBary = [[1, 0, 0], [0, 1, 0], [0, 0, 1]][aBaryIdx + 3] as Vec3;\n                        } else {\n                            aBary = meshRelation.barycentric[aBaryIdx];\n                        }\n\n                        let bBary: Vec3;\n                        if (bBaryIdx < 0) {\n                            bBary = [[1, 0, 0], [0, 1, 0], [0, 0, 1]][bBaryIdx + 3] as Vec3;\n                        } else {\n                            bBary = meshRelation.barycentric[bBaryIdx];\n                        }\n\n                        let cBary: Vec3;\n                        if (cBaryIdx < 0) {\n                            cBary = [[1, 0, 0], [0, 1, 0], [0, 0, 1]][cBaryIdx + 3] as Vec3;\n                        } else {\n                            cBary = meshRelation.barycentric[cBaryIdx];\n                        }\n\n                        let a: number, b: number, c: number;\n                        if (origMesh.indexData) {\n                            let triOffset = origTriIdx * 3;\n                            a = origMesh.indexData[triOffset++];\n                            b = origMesh.indexData[triOffset++];\n                            c = origMesh.indexData[triOffset];\n                        } else {\n                            a = origTriIdx * 3;\n                            b = a + 1;\n                            c = b + 1;\n                        }\n\n                        if (tangentBuffer) {\n                            const origTangents = origMesh.attribute(WL.MeshAttribute.Tangent);\n                            if (origTangents) {\n                                // TODO handle transforms and flips\n                                setFromBary(j4, 4, a, b, c, aBary, bBary, cBary, origTangents, tangentBuffer);\n                            }\n                        }\n\n                        if (normalBuffer) {\n                            const origPositions = origMesh.attribute(WL.MeshAttribute.Position);\n                            const origNormals = origMesh.attribute(WL.MeshAttribute.Normal);\n\n                            if (origPositions && origNormals) {\n                                const [aVec, bVec, cVec] = getFromBary(3, a, b, c, aBary, bBary, cBary, origNormals);\n\n                                // get original face normal\n                                const bOrig = origPositions.get(b);\n                                const abOrig = vec3.sub(vec3.create(), bOrig, origPositions.get(a));\n                                const bcOrig = vec3.sub(vec3.create(), origPositions.get(c), bOrig);\n                                const faceOrig = vec3.cross(vec3.create(), abOrig, bcOrig);\n                                vec3.normalize(faceOrig, faceOrig);\n\n                                // get new face normal\n                                const abNew = vec3.sub(vec3.create(), bPosNew, aPosNew);\n                                const bcNew = vec3.sub(vec3.create(), cPosNew, bPosNew);\n                                const faceNew = vec3.cross(vec3.create(), abNew, bcNew);\n                                vec3.normalize(faceNew, faceNew);\n\n                                // NOTE this doesn't work if, for some bizarre\n                                // reason, vertex normals are pointing inside\n                                // the solid on purpose\n                                // TODO handle transforms and flips\n\n                                // negate normals if necessary\n                                if (vec3.dot(faceOrig, faceNew) < 0) {\n                                    vec3.negate(aVec as Vec3, aVec as Vec3);\n                                    vec3.negate(bVec as Vec3, bVec as Vec3);\n                                    vec3.negate(cVec as Vec3, cVec as Vec3);\n                                }\n\n                                // set normals\n                                normalBuffer.set(aVec, j3);\n                                normalBuffer.set(bVec, j3 + 3);\n                                normalBuffer.set(cVec, j3 + 6);\n                            }\n                        }\n\n                        if (texCoordBuffer) {\n                            const origTexCoords = origMesh.attribute(WL.MeshAttribute.TextureCoordinate);\n                            if (origTexCoords) {\n                                setFromBary(j2, 2, a, b, c, aBary, bBary, cBary, origTexCoords, texCoordBuffer);\n                            }\n                        }\n\n                        if (colorBuffer) {\n                            const origColors = origMesh.attribute(WL.MeshAttribute.Color);\n                            if (origColors) {\n                                setFromBary(j4, 4, a, b, c, aBary, bBary, cBary, origColors, colorBuffer);\n                            }\n                        }\n                    }\n\n                    positionBuffer.set(aPosNew, j3);\n                    positionBuffer.set(bPosNew, j3 + 3);\n                    positionBuffer.set(cPosNew, j3 + 6);\n                }\n            }\n\n            positions.set(0, positionBuffer);\n\n            if (tangentBuffer) {\n                tangents.set(0, tangentBuffer);\n            }\n\n            if (normalBuffer) {\n                normals.set(0, normalBuffer);\n            }\n\n            if (texCoordBuffer) {\n                texCoords.set(0, texCoordBuffer);\n            }\n\n            if (colorBuffer) {\n                colors.set(0, colorBuffer);\n            }\n\n            meshArr.push([wleMesh, material]);\n        }\n\n        return meshArr;\n    }\n\n    private async initializeSingle(displayID: number): Promise<void> {\n        const worker = new Worker(this.workerPath, { name: `manifold-worker-${displayID}` });\n\n        return new Promise((resolve, reject) => {\n            let stage = 0;\n            worker.onmessage = (event: MessageEvent<WorkerResponse>) => {\n                switch(event.data.type) {\n                case 'created':\n                    if (stage === 0) {\n                        stage++;\n                        worker.postMessage({\n                            type: 'initialize',\n                            libraryPath: this.libraryPath\n                        });\n                    } else {\n                        // TODO\n                    }\n                    break;\n                case 'ready':\n                    if (stage === 1) {\n                        stage++;\n                        resolve();\n                        (this.workers as WorkerArray).push([worker, 0]);\n                    } else {\n                        // TODO\n                    }\n                    break;\n                case 'terminated':\n                    // TODO handle already dispatched jobs\n                    if (this.workers) {\n                        for (const [i, [otherWorker, _jobCount]] of this.workers.entries()) {\n                            if (otherWorker === worker) {\n                                this.workers.splice(i, 1);\n                                break;\n                            }\n                        }\n                    }\n\n                    worker.terminate();\n                    reject();\n                    break;\n                case 'result':\n                {\n                    const job = this.jobs.get(event.data.jobID);\n                    if (!job) {\n                        console.warn(`Ignored invalid job ID (${event.data.jobID})`);\n                        break;\n                    }\n\n                    const [jobResolve, jobReject, origMap] = job;\n                    if (event.data.success) {\n                        const result = event.data.result;\n\n                        if (Array.isArray(result)) {\n                            const [mesh, meshRelation, meshIDMap] = result;\n                            const mappedOrigMap = new Map<number, BaseManifoldWLMesh | WL.Mesh>();\n\n                            for (const [src, dst] of meshIDMap) {\n                                const orig = origMap[dst];\n                                if (orig) {\n                                    mappedOrigMap.set(src, orig);\n                                }\n                            }\n\n                            jobResolve(this.meshToWLEArr(mesh, meshRelation, mappedOrigMap));\n                        } else {\n                            jobResolve(result);\n                        }\n                    } else {\n                        jobReject(event.data.error);\n                    }\n                    break;\n                }\n                default:\n                    console.warn('Unexpected message from worker:', event.data);\n                }\n            }\n        })\n    }\n\n    private async initialize(): Promise<void> {\n        this.workers = [];\n        const promises = new Array<Promise<unknown>>();\n\n        for (let i = 0; i < this.wantedWorkerCount; i++) {\n            promises.push(this.initializeSingle(i));\n        }\n\n        await Promise.allSettled(promises);\n\n        if (this.workers.length === 0) {\n            throw new Error('No worker was successfuly created');\n        }\n    }\n\n    private getBestWorker(): WorkerTuple {\n        const workers = this.workers as WorkerArray;\n        let bestWorker = workers[0];\n\n        for (let i = 1; i < workers.length; i++) {\n            const thisWorker = workers[i];\n\n            if (thisWorker[1] < bestWorker[1]) {\n                bestWorker = thisWorker;\n            }\n        }\n\n        return bestWorker;\n    }\n\n    async dispatch(operation: CSGOperation<BaseManifoldWLMesh | WL.Mesh>): Promise<JobResult> {\n        if (!this.workers) {\n            await this.initialize();\n        }\n\n        if ((this.workers as WorkerArray).length === 0) {\n            throw new Error('All workers failed to initialize');\n        }\n\n        let nextMeshID = 0;\n        const meshIDMap = new Map<number, Mesh>();\n        const origMap = new Array<BaseManifoldWLMesh | WL.Mesh>();\n        iterateOpTree(operation, (context, key, mesh) => {\n            // mesh\n            const converted = this.toManifoldMesh(mesh);\n            meshIDMap.set(nextMeshID, mesh);\n            context[key] = [nextMeshID++, converted];\n            origMap.push(mesh);\n        });\n\n        const best = this.getBestWorker();\n        best[1]++;\n        const jobID = this.nextJobID++;\n\n        return await new Promise((resolve, reject) => {\n            this.jobs.set(jobID, [resolve, reject, origMap]);\n            best[0].postMessage(<WorkerRequest>{\n                type: 'operation', jobID, operation\n            });\n        });\n    }\n}", "import { BaseManifoldWLMesh } from './BaseManifoldWLMesh';\n\nexport class ManifoldWLMesh extends BaseManifoldWLMesh {\n    static fromWLEMesh(mesh: WL.Mesh, material: WL.Material) {\n        return new ManifoldWLMesh([ mesh, material ]);\n    }\n\n    addSubmesh(mesh: WL.Mesh, material: WL.Material): number {\n        this.submeshes.push([ mesh, material ]);\n        return this.submeshCount - 1;\n    }\n\n    clone(materials?: Array<WL.Material>): ManifoldWLMesh {\n        const submeshes = new Array(this.submeshCount);\n\n        for (let i = 0; i < this.submeshCount; i++) {\n            const pair = this.submeshes[i];\n\n            if (materials) {\n                submeshes[i] = [pair[0], materials[i]];\n            } else {\n                submeshes[i] = [pair[0], pair[1]];\n            }\n        }\n\n        return new ManifoldWLMesh(submeshes);\n    }\n}"],
  "mappings": "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",
  "names": ["vec2", "TAU", "makeRegularPolyline", "radius", "sides", "clockwise", "polyline", "sidesM1", "i", "j", "angle", "y", "x", "makeCirclePolyline", "radius", "clockwise", "subDivisions", "makeRegularPolyline", "vec2", "makeCubePolyline", "length", "clockwise", "half", "vec2", "makeRectanglePolyline", "width", "height", "clockwise", "halfWidth", "halfHeight", "vec2", "TAU", "makeStarPolyline", "outerRadius", "innerRadius", "sides", "clockwise", "polyline", "sidesM1", "halfAngle", "k", "i", "j", "outerAngle", "outerY", "outerX", "outerPos", "innerAngle", "innerY", "innerX", "innerPos", "quat", "vec3", "HALF_PI", "TAU", "tq0", "tv0", "tv1", "tv2", "makeRotationMinimizingFrames", "positions", "tangents", "startNormal", "options", "pointCount", "frames", "startTangent", "startBinormal", "v_1", "c_1", "r_i", "t_i", "temp", "r_L_i", "t_L_i", "t_i1", "v_2", "c_2", "r_i1", "s_i1", "endNormal", "twists", "angleErr", "endTangent", "endBinormal", "actualNormal", "dx", "dy", "totalLength", "lastPos", "i", "curPos", "interpLength", "r", "s", "_t", "thisAngleErr", "vec3", "VertexHasher", "k", "data", "seed", "h", "view", "key", "pos", "hash", "arr", "other", "MAX_INDEX_BUFFER_SIZE", "temp0", "vec3", "temp1", "BaseManifoldWLMesh", "submeshes", "premadeManifoldMesh", "submeshMap", "wleMeshes", "i", "wleMesh", "_material", "submeshIdx", "submesh", "triIdx", "offset", "mesh", "triCount", "indexCount", "indexData", "positions", "normals", "j", "tri", "a", "b", "c", "aPos", "bPos", "cPos", "genSubmeshMap", "totalVertexCount", "packedVertexCount", "vertexCount", "totalTriCount", "hasher", "VertexHasher", "jm", "js", "mergedIndices", "pos", "x", "y", "z", "k", "ox", "oy", "oz", "size", "internalCtorKey", "makeUVs", "uSpan", "vSpan", "makeMesh", "quad", "vertPos", "normal", "uvs", "wlMeshOpts", "mesh", "positions", "normals", "texCoords", "finalUVs", "trisFromQuads", "triVerts", "quadIndices", "quadCount", "i", "j", "RectangularCuboidMesh", "BaseManifoldWLMesh", "arg0", "arg1", "arg2", "arg3", "__super", "internalCtorArgs", "width", "height", "depth", "options", "indexType", "indexData", "center", "left", "right", "down", "up", "back", "front", "faceIndices", "manifoldMesh", "leftMesh", "rightMesh", "downMesh", "upMesh", "backMesh", "frontMesh", "submeshMap", "materials", "CubeMesh", "RectangularCuboidMesh", "length", "options", "mat3", "mat4", "vec3", "isClockwise2DPolygon", "polyline", "sum", "vertCount", "last", "next", "sort2DIndices", "polyline", "indices", "_", "i", "aIdx", "bIdx", "a", "b", "getPolygonInLoop", "indices", "start", "end", "indexCount", "output", "i", "actualIndex", "splitPolygonTo", "polyline", "diagonals", "flip", "aIndices", "bIndices", "aDiags", "bDiags", "diagonalCount", "oStart", "oEnd", "outPolyline", "split2DPolygon", "_", "TAU", "isAbove", "p", "q", "interiorAngle", "prev", "cur", "next", "prevAngle", "TAU", "getLeftEdge", "polyline", "status", "vertexCount", "vertex", "leftEdge", "leftY", "lineStartIndex", "lineEndIndex", "lineStart", "lineEnd", "lineMin", "lineMax", "m", "c", "y", "partition2DPolygon", "output", "isClockwiseHint", "isClockwise2DPolygon", "helpers", "types", "diagonals", "index", "sort2DIndices", "prevIndex", "nextIndex", "prevVertex", "nextVertex", "abovePrev", "aboveNext", "prevHelper", "leftHelper", "split2DPolygon", "vec2", "isClockwise2DTriangle", "a", "b", "c", "temp0", "vec2", "temp1", "addTriangle", "output", "index", "clockwise", "a", "b", "c", "polyline", "isClockwise2DTriangle", "isInInterval", "start", "end", "triangulateMonotone2DPolygon", "isClockwiseHint", "vertexCount", "outputSize", "isClockwise2DPolygon", "indices", "sort2DIndices", "secondChainStart", "secondChainEnd", "stack", "i", "thisIndex", "stackLen", "topIndex", "j", "lastPoppedVertex", "lastPoppedIndex", "lastDelta", "nextPoppedIndex", "nextPoppedVertex", "delta", "lastIndex", "iterLen", "triangulate2DPolygon", "polyline", "output", "isClockwiseHint", "isClockwise2DPolygon", "partitions", "partition2DPolygon", "outputSize", "partition", "index", "triangulateMonotone2DPolygon", "internalCtorKey", "temp0", "vec3", "getMatrix", "outputMat", "frame", "position", "t", "mat4", "ExtrusionMesh", "BaseManifoldWLMesh", "arg0", "arg1", "arg2", "arg3", "internalCtorArgs", "polyline", "curvePositions", "curveFrames", "options", "pointCount", "loopLen", "startBaseUVs", "endBaseUVs", "needsExtraPoint", "segmentsUVs", "inputSegmentsUVs", "inputSegmentsUs", "i", "triangulatedBase", "triangulate2DPolygon", "triangulatedBaseLen", "hasSmoothNormals", "manifVertexCount", "segVertexCount", "segmentCount", "baseTriCount", "segmentsTriCount", "manifTriCount", "indexDataStart", "indexTypeStart", "indexDataEnd", "indexTypeEnd", "indexDataSeg", "indexTypeSeg", "manifTriVerts", "manifVertPos", "manifTri", "lLast", "segmentStride", "segmentStrideExtra", "segmentStart", "segmentEnd", "manifSegmentStart", "manifSegmentEnd", "s", "l", "blIdx", "trIdx", "tlIdx", "j", "endWLEIdx", "c", "b", "a", "startMesh", "segMesh", "endMesh", "baseBufLen", "startPositions", "startPosBuf", "startNormals", "startNormBuf", "baseTexCoordBufLen", "startTexCoords", "startTexCoordBuf", "segBufLen", "segPositions", "segPosBuf", "segNormals", "segNormBuf", "segTexCoords", "segTexCoordBuf", "endPositions", "endPosBuf", "endNormals", "endNormBuf", "endTexCoords", "endTexCoordBuf", "hasVertexNormals", "submeshMap", "jEndOffset", "edgeNormals", "smoothNormals", "lXYLast", "mXYLast", "lastEdgeNormal", "m", "lXY", "mXY", "edgeNormal", "lastEdge", "prevEdgeNormal", "smoothNormal", "lastSmoothNormal", "matrix", "extrusionLength", "p", "xy", "pos", "startNormal", "uv", "normalMatrix", "mat3", "curLength", "iTexCoord", "vRange", "lOffset", "u", "v", "u1", "u2", "endNormal", "lEndOffset", "materials", "LinearExtrusionMesh", "ExtrusionMesh", "polyline", "depth", "options", "positions", "forwardFrame", "frames", "iterateOpTreeNode", "context", "key", "node", "handleMesh", "handlePrimitive", "handleOperation", "prim", "i", "op", "iterateOpTree", "tree", "handleTopOperation", "vec3", "getFromBary", "vecSize", "a", "b", "c", "aBary", "bBary", "cBary", "origAccessor", "aOrigVal", "bOrigVal", "cOrigVal", "aVec", "cVec", "bVec", "i", "setFromBary", "buffer", "ManifoldPool", "workerCount", "workerPath", "libraryPath", "wleMesh", "BaseManifoldWLMesh", "mesh", "meshRelation", "meshIDMap", "triCount", "vertexArrays", "iTri", "triBary", "origMesh", "material", "iTriOrig", "vaMap", "va", "meshArr", "vaTotalTriCount", "vertexCount", "indexData", "indexType", "positions", "tangents", "normals", "texCoords", "colors", "hasExtra", "positionBuffer", "tangentBuffer", "normalBuffer", "texCoordBuffer", "colorBuffer", "j2", "j3", "j4", "vaTriCount", "triIdx", "origTriIdx", "triIndices", "aPosNew", "bPosNew", "cPosNew", "aBaryIdx", "bBaryIdx", "cBaryIdx", "triOffset", "origTangents", "origPositions", "origNormals", "bOrig", "abOrig", "vec3", "bcOrig", "faceOrig", "abNew", "bcNew", "faceNew", "origTexCoords", "origColors", "displayID", "worker", "resolve", "reject", "stage", "event", "otherWorker", "_jobCount", "job", "jobResolve", "jobReject", "origMap", "result", "mappedOrigMap", "src", "dst", "orig", "promises", "workers", "bestWorker", "thisWorker", "operation", "nextMeshID", "iterateOpTree", "context", "key", "converted", "best", "jobID", "ManifoldWLMesh", "BaseManifoldWLMesh", "mesh", "material", "materials", "submeshes", "i", "pair"]
}
