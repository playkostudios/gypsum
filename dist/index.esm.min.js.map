{
  "version": 3,
  "sources": ["../src/common/iterate-operation-tree.ts", "../src/common/VertexHasher.ts", "../src/client.ts"],
  "sourcesContent": ["import type { CSGFinalOperation } from './CSGFinalOperation';\nimport { CSGGeometricOperation } from './CSGGeometricOperation';\nimport type { CSGOperation } from './CSGOperation';\nimport type { CSGPrimitive } from './CSGPrimitive';\nimport type { CSGTree } from './CSGTree';\n\nexport type OpTreeCtx<MeshType> = { [key: string | number]: (CSGTree<MeshType> | MeshType) };\n\nfunction iterateOpTreeNode<MeshType>(context: OpTreeCtx<MeshType>, key: string | number, node: CSGTree<MeshType> | MeshType, handleMesh: ((context: OpTreeCtx<MeshType>, key: string | number, mesh: MeshType) => void) | null = null, handlePrimitive: ((context: OpTreeCtx<MeshType>, key: string | number, operation: CSGPrimitive) => void) | null = null, handleOperation: ((context: OpTreeCtx<MeshType>, key: string | number, operation: CSGGeometricOperation<MeshType>) => void) | null = null): void {\n    if ('primitive' in node) {\n        // primitive\n        switch (node.primitive) {\n            case 'cube':\n            case 'cylinder':\n            case 'sphere':\n            case 'tetrahedron':\n                if (handlePrimitive) {\n                    handlePrimitive(context, key, node);\n                }\n                break;\n            default: {\n                // XXX we're kinda fighting the type system here, but oh well\n                const prim = (node as {primitive: string}).primitive;\n                throw new Error(`Unknown primitive: ${prim}`);\n            }\n        }\n    } else if ('operation' in node) {\n        // operation\n        switch (node.operation) {\n            case 'add':\n            case 'union':\n            case 'subtract':\n            case 'difference':\n            case 'intersect':\n            case 'intersection': {\n                // XXX children are iterated from right to left so that they can\n                // be pushed to a stack and then popped at the right order\n                if ('manifolds' in node) {\n                    for (let i = node.manifolds.length - 1; i >= 0; i--) {\n                        iterateOpTreeNode(node.manifolds as unknown as OpTreeCtx<MeshType>, i, node.manifolds[i], handleMesh, handlePrimitive, handleOperation);\n                    }\n                } else {\n                    iterateOpTreeNode(node as unknown as OpTreeCtx<MeshType>, 'right', node.right, handleMesh, handlePrimitive, handleOperation);\n                    iterateOpTreeNode(node as unknown as OpTreeCtx<MeshType>, 'left', node.left, handleMesh, handlePrimitive, handleOperation);\n                }\n\n                if (handleOperation) {\n                    handleOperation(context, key, node);\n                }\n                break;\n            }\n            case 'translate':\n            case 'rotate':\n            case 'scale':\n            case 'transform':\n            case 'refine':\n            case 'asOriginal':\n                iterateOpTreeNode(node as unknown as OpTreeCtx<MeshType>, 'manifold', node.manifold, handleMesh, handlePrimitive, handleOperation);\n                // XXX intentional fallthrough\n            case 'extrude':\n            case 'revolve':\n                if (handleOperation) {\n                    handleOperation(context, key, node);\n                }\n                break;\n            default: {\n                // XXX fighting the type system again...\n                const op = (node as {operation: string}).operation;\n                if (op === 'compose' || op === 'decompose') {\n                    throw new Error(`${op} operation is not implemented yet`);\n                } else {\n                    throw new Error(`Unknown operation: ${op}`);\n                }\n            }\n        }\n    } else {\n        // assume this is a mesh object\n        if (handleMesh) {\n            handleMesh(context, key, node);\n        }\n    }\n}\n\nexport function iterateOpTree<MeshType>(tree: CSGOperation<MeshType>, handleMesh: ((context: OpTreeCtx<MeshType>, key: string | number, mesh: MeshType) => void) | null = null, handlePrimitive: ((context: OpTreeCtx<MeshType>, key: string | number, operation: CSGPrimitive) => void) | null = null, handleOperation: ((context: OpTreeCtx<MeshType>, key: string | number, operation: CSGGeometricOperation<MeshType>) => void) | null = null, handleTopOperation: ((context: OpTreeCtx<MeshType>, key: string | number, topOperation: CSGFinalOperation<MeshType>) => void) | null = null): void {\n    const context = <OpTreeCtx<MeshType>>{\n        root: tree\n    };\n\n    if ('primitive' in tree) {\n        if (handlePrimitive) {\n            handlePrimitive(context, 'root', tree);\n        }\n    } else {\n        switch (tree.operation) {\n            case 'isEmpty':\n            case 'numVert':\n            case 'numTri':\n            case 'numEdge':\n            case 'boundingBox':\n            case 'precision':\n            case 'genus':\n            case 'getProperties':\n            case 'getCurvature':\n            case 'originalID':\n                iterateOpTreeNode(tree as unknown as OpTreeCtx<MeshType>, 'manifold', tree.manifold, handleMesh, handlePrimitive, handleOperation);\n\n                if (handleTopOperation) {\n                    handleTopOperation(context, 'root', tree);\n                }\n                break;\n            default:\n                iterateOpTreeNode(context, 'root', tree, handleMesh, handlePrimitive, handleOperation);\n        }\n    }\n}", "// XXX modified TriangleHasher from our OctreeCSG-ea project, but reused for\n// vertex positions instead of triangles\nexport default class VertexHasher {\n    buckets = new Map<number, Float32Array[]>;\n\n    private murmur_32_scramble(k: number): number {\n        k *= 0xcc9e2d51;\n        k = (k << 15) | (k >> 17);\n        k *= 0x1b873593;\n        return k & 0xffffffff;\n    }\n\n    private murmur3_32(data: Float32Array, seed: number): number {\n        let h = seed;\n\n        /* Read in groups of 4. */\n        const view = new Uint32Array(data.buffer);\n        for (const key of view) {\n            h ^= this.murmur_32_scramble(key);\n            h = ((h << 13) & 0xffffffff) | (h >> 19);\n            h = (h * 5 + 0xe6546b64) & 0xffffffff;\n        }\n\n        /* Finalize. */\n        h ^= view.byteLength;\n        h ^= h >> 16;\n        h = (h * 0x85ebca6b) & 0xffffffff;\n        h ^= h >> 13;\n        h = (h * 0xc2b2ae35) & 0xffffffff;\n        h ^= h >> 16;\n        return h;\n    }\n\n    private getHash(pos: Float32Array): number {\n        return this.murmur3_32(pos, 0xea8ed414);\n    }\n\n    isUnique(pos: Float32Array) {\n        const hash = this.getHash(pos);\n        const arr = this.buckets.get(hash);\n\n        if (arr) {\n            for (const other of arr) {\n                if (pos[0] === other[0] && pos[1] === other[1] && pos[2] === other[2]) {\n                    return false;\n                }\n            }\n\n            arr.push(pos);\n        } else {\n            this.buckets.set(hash, [pos]);\n        }\n\n        return true;\n    }\n\n    clear() {\n        this.buckets.clear();\n    }\n}", "// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path=\"../types/globals.d.ts\" />\n\nimport { CSGOperation } from './common/CSGOperation';\nimport { iterateOpTree } from './common/iterate-operation-tree';\nimport { WorkerResponse } from './common/WorkerResponse';\nimport VertexHasher from './common/VertexHasher';\nimport { vec3 } from 'gl-matrix';\n\ntype OrigTris = Array<[a: number, b: number, c: number]>;\ntype TriMap = Map<WL.Mesh, OrigTris>;\ntype MeshArr = Array<[mesh: WL.Mesh, material: WL.Material | null]>;\ntype WorkerTuple = [worker: Worker, jobCount: number];\ntype WorkerArray = Array<WorkerTuple>;\ntype JobResult = MeshArr | boolean | number | Box | Properties | Curvature;\n\nfunction getFromBary(vecSize: number, a: number, b: number, c: number, aBary: Vec3, bBary: Vec3, cBary: Vec3, origAccessor: WL.MeshAttributeAccessor) {\n    const aOrigVal = origAccessor.get(a);\n    const bOrigVal = origAccessor.get(b);\n    const cOrigVal = origAccessor.get(c);\n    const aVec = new Array(vecSize);\n    const cVec = new Array(vecSize);\n    const bVec = new Array(vecSize);\n\n    for (let j = 0; j < vecSize; j++) {\n        aVec[j] = aOrigVal[j] * aBary[0] + bOrigVal[j] * aBary[1] + cOrigVal[j] * aBary[2];\n        bVec[j] = aOrigVal[j] * bBary[0] + bOrigVal[j] * bBary[1] + cOrigVal[j] * bBary[2];\n        cVec[j] = aOrigVal[j] * cBary[0] + bOrigVal[j] * cBary[1] + cOrigVal[j] * cBary[2];\n    }\n\n    return [aVec, bVec, cVec];\n}\n\nfunction setFromBary(i: number, vecSize: number, a: number, b: number, c: number, aBary: Vec3, bBary: Vec3, cBary: Vec3, origAccessor: WL.MeshAttributeAccessor, buffer: Float32Array) {\n    const [aVec, bVec, cVec] = getFromBary(vecSize, a, b, c, aBary, bBary, cBary, origAccessor);\n    buffer.set(aVec, i);\n    buffer.set(bVec, i + 3);\n    buffer.set(cVec, i + 6);\n}\n\nexport class ManifoldPool {\n    private wantedWorkerCount: number;\n    private workerPath: string;\n    private libraryPath: string;\n    private workers: WorkerArray | null = null;\n    private nextJobID = 0;\n    private jobs = new Map<number, [resolve: (value: JobResult) => void, reject: (reason: unknown) => void, origMeshes: Array<Mesh | WL.Mesh>, materialMap: Map<WL.Mesh | Mesh, WL.Material>, triMap: TriMap]>();\n\n    constructor(workerCount: number | null = null, workerPath = 'manifold-wle.worker.min.js', libraryPath = 'manifold.js') {\n        this.wantedWorkerCount = Math.max(\n            1, workerCount ?? Math.ceil(navigator.hardwareConcurrency / 2)\n        );\n        this.workerPath = workerPath;\n        this.libraryPath = libraryPath;\n    }\n\n    private meshFromWLE(wleMesh: WL.Mesh | null): [Mesh, OrigTris] {\n        // validate vertex count\n        const indexData = wleMesh.indexData;\n        const packedVertexCount = wleMesh.vertexCount;\n        const vertexCount = indexData === null ? packedVertexCount : indexData.length;\n\n        if (vertexCount % 3 !== 0) {\n            throw new Error(`Mesh has an invalid vertex count (${vertexCount}). Must be a multiple of 3`);\n        }\n\n        // prepare accessors\n        const positions = wleMesh.attribute(WL.MeshAttribute.Position);\n        const triCount = vertexCount / 3;\n        const mesh = {\n            vertPos: new Array<Vec3>(),\n            triVerts: new Array<Vec3>(triCount)\n        }\n\n        // convert positions\n        const hasher = new VertexHasher();\n        const mergedIndices = new Array<number>();\n        let nextIdx = 0;\n        for (let i = 0; i < packedVertexCount; i++) {\n            const pos = positions.get(i);\n\n            if (hasher.isUnique(pos)) {\n                mesh.vertPos.push(pos);\n                mergedIndices.push(nextIdx++);\n            } else {\n                const [x, y, z] = pos;\n                let j = 0;\n                for (; j < mesh.vertPos.length; j++) {\n                    const [ox, oy, oz] = mesh.vertPos[j];\n                    if (ox === x && oy === y && oz === z) {\n                        break;\n                    }\n                }\n\n                if (j === mesh.vertPos.length) {\n                    mesh.vertPos.push(pos);\n                    mergedIndices.push(nextIdx++);\n                } else {\n                    mergedIndices.push(j);\n                }\n            }\n        }\n\n        // make triangles\n        let j = 0;\n        const origTris: OrigTris = new Array(triCount);\n        if (indexData === null) {\n            for (let i = 0; i < vertexCount; i += 3) {\n                origTris[j] = [i, i + 1, i + 2];\n                mesh.triVerts[j++] = [\n                    mergedIndices[i], mergedIndices[i + 1], mergedIndices[i + 2]\n                ];\n            }\n        } else {\n            for (let i = 0; i < vertexCount;) {\n                const a = indexData[i++];\n                const b = indexData[i++];\n                const c = indexData[i++];\n\n                origTris[j] = [a, b, c];\n                mesh.triVerts[j++] = [\n                    mergedIndices[a], mergedIndices[b], mergedIndices[c]\n                ];\n            }\n        }\n\n        return [mesh, origTris];\n    }\n\n    private meshToWLEArr(mesh: Mesh, triMap: TriMap, meshRelation: MeshRelation, meshIDMap: Map<number, WL.Mesh | Mesh>, materialMap: Map<WL.Mesh | Mesh, WL.Material>): MeshArr {\n        // validate triangle count\n        const triCount = mesh.triVerts.length;\n\n        if (triCount === 0) {\n            return [];\n        }\n\n        // map triangles to materials\n        const vertexArrays = new Map<WL.Material | null, Array<number>>();\n        let iTri = 0;\n        for (; iTri < triCount; iTri++) {\n            // get original triangle\n            const triBary = meshRelation.triBary[iTri];\n            const origMesh = meshIDMap.get(triBary.originalID);\n            const material = materialMap.get(origMesh) ?? null;\n\n            // get vertex array\n            let va = vertexArrays.get(material);\n            if (!va) {\n                va = [];\n                vertexArrays.set(material, va);\n            }\n\n            // add triangle points to vertex array\n            va.push(iTri);\n        }\n\n        // make mesh for each vertex array\n        const meshArr: MeshArr = [];\n\n        for (const [material, va] of vertexArrays) {\n            // make index buffer\n            const vaTriCount = va.length;\n            const vertexCount = vaTriCount * 3;\n            let indexType: WL.MeshIndexType, indexData: Uint8Array | Uint16Array | Uint32Array;\n            if (vertexCount <= 255) {\n                indexType = WL.MeshIndexType.UnsignedByte;\n                indexData = new Uint8Array(vertexCount);\n            } else if (vertexCount <= 65535) {\n                indexType = WL.MeshIndexType.UnsignedShort;\n                indexData = new Uint16Array(vertexCount);\n            } else {\n                indexType = WL.MeshIndexType.UnsignedInt;\n                indexData = new Uint32Array(vertexCount);\n            }\n\n            for (let i = 0; i < vertexCount; i++) {\n                indexData[i] = i;\n            }\n\n            // make mesh from index buffer\n            const wleMesh = new WL.Mesh({ vertexCount, indexType, indexData });\n            const positions = wleMesh.attribute(WL.MeshAttribute.Position);\n\n            const tangents = wleMesh.attribute(WL.MeshAttribute.Tangent);\n            const normals = wleMesh.attribute(WL.MeshAttribute.Normal);\n            const texCoords = wleMesh.attribute(WL.MeshAttribute.TextureCoordinate);\n            const colors = wleMesh.attribute(WL.MeshAttribute.Color);\n            // TODO joint support?\n            const hasExtra: boolean = (tangents || normals || texCoords || colors);\n\n            const positionBuffer = new Float32Array(vertexCount * 3);\n\n            let tangentBuffer: Float32Array | undefined;\n            if (tangents) {\n                tangentBuffer = new Float32Array(vertexCount * 4);\n            }\n\n            let normalBuffer: Float32Array | undefined;\n            if (normals) {\n                normalBuffer = new Float32Array(vertexCount * 3);\n            }\n\n            let texCoordBuffer: Float32Array | undefined;\n            if (texCoords) {\n                texCoordBuffer = new Float32Array(vertexCount * 2);\n            }\n\n            let colorBuffer: Float32Array | undefined;\n            if (colors) {\n                colorBuffer = new Float32Array(vertexCount * 4);\n            }\n\n            for (let i = 0, j2 = 0, j3 = 0, j4 = 0; i < vaTriCount; i++, j2 += 6, j3 += 9, j4 += 16) {\n                const triIdx = va[i];\n                const triIndices = mesh.triVerts[triIdx];\n                const triBary = meshRelation.triBary[triIdx];\n                const origMesh = meshIDMap.get(triBary.originalID);\n\n                const aPosNew = mesh.vertPos[triIndices[0]];\n                const bPosNew = mesh.vertPos[triIndices[1]];\n                const cPosNew = mesh.vertPos[triIndices[2]];\n\n                if (hasExtra && origMesh && origMesh instanceof WL.Mesh) {\n                    const origTris = triMap.get(origMesh) as OrigTris;\n\n                    const aBaryIdx = triBary.vertBary[0];\n                    const bBaryIdx = triBary.vertBary[1];\n                    const cBaryIdx = triBary.vertBary[2];\n\n                    let aBary: Vec3;\n                    if (aBaryIdx < 0) {\n                        aBary = [[1, 0, 0], [0, 1, 0], [0, 0, 1]][aBaryIdx + 3] as Vec3;\n                    } else {\n                        aBary = meshRelation.barycentric[aBaryIdx];\n                    }\n\n                    let bBary: Vec3;\n                    if (bBaryIdx < 0) {\n                        bBary = [[1, 0, 0], [0, 1, 0], [0, 0, 1]][bBaryIdx + 3] as Vec3;\n                    } else {\n                        bBary = meshRelation.barycentric[bBaryIdx];\n                    }\n\n                    let cBary: Vec3;\n                    if (cBaryIdx < 0) {\n                        cBary = [[1, 0, 0], [0, 1, 0], [0, 0, 1]][cBaryIdx + 3] as Vec3;\n                    } else {\n                        cBary = meshRelation.barycentric[cBaryIdx];\n                    }\n\n                    const [a, b, c] = origTris[triBary.tri];\n\n                    if (tangentBuffer) {\n                        const origTangents = origMesh.attribute(WL.MeshAttribute.Tangent);\n                        if (origTangents) {\n                            setFromBary(j4, 4, a, b, c, aBary, bBary, cBary, origTangents, tangentBuffer);\n                        }\n                    }\n\n                    if (normalBuffer) {\n                        const origPositions = origMesh.attribute(WL.MeshAttribute.Position);\n                        const origNormals = origMesh.attribute(WL.MeshAttribute.Normal);\n\n                        if (origPositions && origNormals) {\n                            const [aVec, bVec, cVec] = getFromBary(3, a, b, c, aBary, bBary, cBary, origNormals);\n\n                            // get original face normal\n                            const bOrig = origPositions.get(b);\n                            const abOrig = vec3.sub(vec3.create(), bOrig, origPositions.get(a));\n                            const bcOrig = vec3.sub(vec3.create(), origPositions.get(c), bOrig);\n                            const faceOrig = vec3.cross(vec3.create(), abOrig, bcOrig);\n                            vec3.normalize(faceOrig, faceOrig);\n\n                            // get new face normal\n                            const abNew = vec3.sub(vec3.create(), bPosNew, aPosNew);\n                            const bcNew = vec3.sub(vec3.create(), cPosNew, bPosNew);\n                            const faceNew = vec3.cross(vec3.create(), abNew, bcNew);\n                            vec3.normalize(faceNew, faceNew);\n\n                            // negate normals if necessary\n                            if (vec3.dot(faceOrig, faceNew) < 0) {\n                                vec3.negate(aVec as Vec3, aVec as Vec3);\n                                vec3.negate(bVec as Vec3, bVec as Vec3);\n                                vec3.negate(cVec as Vec3, cVec as Vec3);\n                            }\n\n                            // set normals\n                            normalBuffer.set(aVec, j3);\n                            normalBuffer.set(bVec, j3 + 3);\n                            normalBuffer.set(cVec, j3 + 6);\n                        }\n                    }\n\n                    if (texCoordBuffer) {\n                        const origTexCoords = origMesh.attribute(WL.MeshAttribute.Tangent);\n                        if (origTexCoords) {\n                            setFromBary(j2, 2, a, b, c, aBary, bBary, cBary, origTexCoords, texCoordBuffer);\n                        }\n                    }\n\n                    if (colorBuffer) {\n                        const origColors = origMesh.attribute(WL.MeshAttribute.Color);\n                        if (origColors) {\n                            setFromBary(j4, 4, a, b, c, aBary, bBary, cBary, origColors, colorBuffer);\n                        }\n                    }\n                }\n\n                positionBuffer.set(aPosNew, j3);\n                positionBuffer.set(bPosNew, j3 + 3);\n                positionBuffer.set(cPosNew, j3 + 6);\n            }\n\n            positions.set(0, positionBuffer);\n\n            if (tangentBuffer) {\n                tangents.set(0, tangentBuffer);\n            }\n\n            if (normalBuffer) {\n                normals.set(0, normalBuffer);\n            }\n\n            if (texCoordBuffer) {\n                texCoords.set(0, texCoordBuffer);\n            }\n\n            if (colorBuffer) {\n                colors.set(0, colorBuffer);\n            }\n\n            meshArr.push([wleMesh, material]);\n        }\n\n        return meshArr;\n    }\n\n    private async initializeSingle(displayID: number): Promise<void> {\n        const worker = new Worker(this.workerPath, { name: `manifold-worker-${displayID}` });\n\n        return new Promise((resolve, reject) => {\n            let stage = 0;\n            worker.onmessage = (event: MessageEvent<WorkerResponse>) => {\n                switch(event.data.type) {\n                case 'created':\n                    if (stage === 0) {\n                        stage++;\n                        worker.postMessage({\n                            type: 'initialize',\n                            libraryPath: this.libraryPath\n                        });\n                    } else {\n                        // TODO\n                    }\n                    break;\n                case 'ready':\n                    if (stage === 1) {\n                        stage++;\n                        resolve();\n                        (this.workers as WorkerArray).push([worker, 0]);\n                    } else {\n                        // TODO\n                    }\n                    break;\n                case 'terminated':\n                    // TODO handle already dispatched jobs\n                    if (this.workers) {\n                        for (const [i, [otherWorker, _jobCount]] of this.workers.entries()) {\n                            if (otherWorker === worker) {\n                                this.workers.splice(i, 1);\n                                break;\n                            }\n                        }\n                    }\n\n                    worker.terminate();\n                    reject();\n                    break;\n                case 'result':\n                {\n                    const job = this.jobs.get(event.data.jobID);\n                    if (!job) {\n                        console.warn(`Ignored invalid job ID (${event.data.jobID})`);\n                        break;\n                    }\n\n                    const [jobResolve, jobReject, origMap, materialMap, triMap] = job;\n                    if (event.data.success) {\n                        const result = event.data.result;\n\n                        if (Array.isArray(result)) {\n                            const [mesh, meshRelation, meshIDMap] = result;\n                            const mappedOrigMap = new Map<number, WL.Mesh | Mesh>();\n\n                            for (const [src, dst] of meshIDMap) {\n                                const orig = origMap[dst];\n                                if (orig) {\n                                    mappedOrigMap.set(src, orig);\n                                }\n                            }\n\n                            jobResolve(this.meshToWLEArr(mesh, triMap, meshRelation, mappedOrigMap, materialMap));\n                        } else {\n                            jobResolve(result);\n                        }\n                    } else {\n                        jobReject(event.data.error);\n                    }\n                    break;\n                }\n                default:\n                    console.warn('Unexpected message from worker:', event.data);\n                }\n            }\n        })\n    }\n\n    private async initialize(): Promise<void> {\n        this.workers = [];\n        const promises = new Array<Promise<unknown>>();\n\n        for (let i = 0; i < this.wantedWorkerCount; i++) {\n            promises.push(this.initializeSingle(i));\n        }\n\n        await Promise.allSettled(promises);\n\n        if (this.workers.length === 0) {\n            throw new Error('No worker was successfuly created');\n        }\n    }\n\n    private getBestWorker(): WorkerTuple {\n        const workers = this.workers as WorkerArray;\n        let bestWorker = workers[0];\n\n        for (let i = 1; i < workers.length; i++) {\n            const thisWorker = workers[i];\n\n            if (thisWorker[1] < bestWorker[1]) {\n                bestWorker = thisWorker;\n            }\n        }\n\n        return bestWorker;\n    }\n\n    async dispatch(operation: CSGOperation<WL.Mesh | Mesh>, materialMap?: Map<WL.Mesh | Mesh, WL.Material>): Promise<JobResult> {\n        if (!this.workers) {\n            await this.initialize();\n        }\n\n        if ((this.workers as WorkerArray).length === 0) {\n            throw new Error('All workers failed to initialize');\n        }\n\n        let nextMeshID = 0;\n        const meshIDMap = new Map<number, Mesh>();\n        const origMap = new Array<WL.Mesh | Mesh>();\n        const triMap = new Map<WL.Mesh, OrigTris>();\n        iterateOpTree(operation, (context, key, mesh) => {\n            // mesh\n            let converted = mesh;\n            if (mesh instanceof WL.Mesh) {\n                let origTris: OrigTris;\n                [converted, origTris] = this.meshFromWLE(mesh);\n                triMap.set(mesh, origTris);\n            }\n\n            meshIDMap.set(nextMeshID, mesh);\n            context[key] = [nextMeshID++, converted];\n            origMap.push(mesh);\n        });\n\n        const best = this.getBestWorker();\n        best[1]++;\n        const jobID = this.nextJobID++;\n\n        const finalMaterialMap = new Map(materialMap?.entries());\n\n        return await new Promise((resolve, reject) => {\n            this.jobs.set(jobID, [resolve, reject, origMap, finalMaterialMap, triMap]);\n            best[0].postMessage({ type: 'operation', jobID, operation });\n        });\n    }\n}"],
  "mappings": "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",
  "names": ["iterateOpTreeNode", "context", "key", "node", "handleMesh", "handlePrimitive", "handleOperation", "prim", "op", "iterateOpTree", "tree", "handleTopOperation", "VertexHasher", "k", "data", "seed", "h", "view", "key", "pos", "hash", "arr", "other", "vec3", "getFromBary", "vecSize", "a", "b", "c", "aBary", "bBary", "cBary", "origAccessor", "aOrigVal", "bOrigVal", "cOrigVal", "aVec", "cVec", "bVec", "j", "setFromBary", "i", "buffer", "ManifoldPool", "workerCount", "workerPath", "libraryPath", "wleMesh", "indexData", "packedVertexCount", "vertexCount", "positions", "triCount", "mesh", "hasher", "VertexHasher", "mergedIndices", "nextIdx", "pos", "x", "z", "ox", "oy", "oz", "origTris", "triMap", "meshRelation", "meshIDMap", "materialMap", "vertexArrays", "iTri", "triBary", "origMesh", "material", "va", "meshArr", "vaTriCount", "indexType", "tangents", "normals", "texCoords", "colors", "hasExtra", "positionBuffer", "tangentBuffer", "normalBuffer", "texCoordBuffer", "colorBuffer", "j2", "j3", "j4", "triIdx", "triIndices", "aPosNew", "bPosNew", "cPosNew", "aBaryIdx", "bBaryIdx", "cBaryIdx", "origTangents", "origPositions", "origNormals", "bOrig", "abOrig", "bcOrig", "faceOrig", "abNew", "bcNew", "faceNew", "origTexCoords", "origColors", "displayID", "worker", "resolve", "reject", "stage", "event", "otherWorker", "_jobCount", "job", "jobResolve", "jobReject", "origMap", "result", "mappedOrigMap", "src", "dst", "orig", "promises", "workers", "bestWorker", "thisWorker", "operation", "nextMeshID", "iterateOpTree", "context", "key", "converted", "best", "jobID", "finalMaterialMap"]
}
